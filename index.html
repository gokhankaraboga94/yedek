<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cep ƒ∞mparatorluƒüu: Legends v4.5 (TC Son Hedef)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #2c3e50;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
        }

        /* START & RESTART SCREEN */
        #start-screen,
        #restart-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(44, 62, 80, 0.95), rgba(0, 0, 0, 0.95));
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            color: white;
            text-align: center;
        }

        #restart-overlay {
            display: none;
            background: rgba(0, 0, 0, 0.85);
        }

        h1 {
            font-size: 40px;
            color: #f1c40f;
            text-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            margin-bottom: 10px;
        }

        p {
            font-size: 18px;
            color: #ecf0f1;
            margin-bottom: 30px;
            max-width: 80%;
        }

        .big-btn {
            background: linear-gradient(to bottom, #e67e22, #d35400);
            border: 2px solid #f1c40f;
            color: white;
            padding: 15px 40px;
            font-size: 24px;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(230, 126, 34, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
            animation: pulse 2s infinite;
            pointer-events: auto;
        }

        .big-btn:active {
            transform: scale(0.95);
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(230, 126, 34, 0.7);
            }

            70% {
                box-shadow: 0 0 0 20px rgba(230, 126, 34, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(230, 126, 34, 0);
            }
        }

        /* RESOURCES & UI */
        #resources {
            display: flex;
            justify-content: space-around;
            background: linear-gradient(to bottom, #2c2217, #1a120b);
            color: #f1c40f;
            padding: 8px;
            font-size: 14px;
            font-weight: bold;
            pointer-events: auto;
            border-bottom: 3px solid #c0392b;
            box-shadow: 0 2px 15px rgba(0, 0, 0, 0.8);
            font-family: 'Courier New', monospace;
        }

        .res-item {
            display: flex;
            align-items: center;
            text-shadow: 1px 1px 0 #000;
        }

        .res-icon {
            margin-right: 5px;
            font-size: 16px;
        }

        #bottom-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(30, 39, 46, 0.95);
            padding: 10px;
            display: flex;
            overflow-x: auto;
            pointer-events: auto;
            border-top: 3px solid #f1c40f;
            height: 95px;
            align-items: center;
            justify-content: flex-start;
            gap: 5px;
        }

        #bottom-panel::-webkit-scrollbar {
            height: 5px;
        }

        #bottom-panel::-webkit-scrollbar-thumb {
            background: #f1c40f;
            border-radius: 10px;
        }

        .action-btn {
            background: linear-gradient(to bottom, #34495e, #2c3e50);
            color: #ecf0f1;
            border: 2px solid #7f8c8d;
            border-radius: 8px;
            min-width: 75px;
            height: 75px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            cursor: pointer;
            box-shadow: 0 4px 0 #1a252f;
            transition: transform 0.1s;
            position: relative;
        }

        .action-btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #1a252f;
        }

        .action-btn span {
            font-size: 22px;
            margin-bottom: 2px;
        }

        .destroy-btn {
            background: linear-gradient(to bottom, #c0392b, #8e44ad) !important;
            border-color: #e74c3c !important;
        }

        .rally-btn {
            background: linear-gradient(to bottom, #27ae60, #16a085) !important;
            border-color: #2ecc71 !important;
        }

        .gather-btn {
            background: linear-gradient(to bottom, #8e44ad, #9b59b6) !important;
            border-color: #9b59b6 !important;
        }

        .special-btn {
            background: linear-gradient(to bottom, #8e44ad, #9b59b6) !important;
            border-color: #9b59b6 !important;
        }

        .siege-btn {
            background: linear-gradient(to bottom, #5d4037, #3e2723) !important;
            border-color: #f39c12 !important;
        }

        .melee-btn {
            background: linear-gradient(to bottom, #7f8c8d, #34495e) !important;
            border-color: #bdc3c7 !important;
        }

        .guard-btn {
            background: linear-gradient(to bottom, #7f8c8d, #34495e) !important;
            border-color: #bdc3c7 !important;
        }

        .cost {
            color: #f39c12;
            font-size: 9px;
            margin-top: 2px;
            text-align: center;
            line-height: 1.1;
        }

        #notifications {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            width: 90%;
            pointer-events: none;
            z-index: 100;
        }

        .toast {
            background: rgba(0, 0, 0, 0.8);
            border-left: 5px solid #f1c40f;
            color: #fff;
            padding: 8px 15px;
            border-radius: 4px;
            margin-bottom: 5px;
            font-size: 14px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.5s;
            text-shadow: 1px 1px 0 #000;
            display: inline-block;
        }

        #selection-info {
            position: absolute;
            bottom: 120px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #ecf0f1;
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #7f8c8d;
            font-size: 13px;
            display: none;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        /* YENƒ∞ GLOBAL KOMUTLAR VE ZOOM */
        #global-commands {
            position: absolute;
            top: 70px;
            right: 10px;
            display: flex;
            flex-direction: column;
            pointer-events: auto;
        }

        #zoom-controls {
            display: flex;
            flex-direction: column;
            pointer-events: auto;
            margin-bottom: 10px;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: 1px solid #7f8c8d;
            border-radius: 5px;
            margin-bottom: 5px;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .global-retreat-btn {
            width: 40px;
            height: 40px;
            background: linear-gradient(to bottom, #ecf0f1, #bdc3c7);
            color: #2c3e50;
            border: 2px solid #f1c40f;
            border-radius: 5px;
            margin-bottom: 5px;
            font-size: 20px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 3px 0 #95a5a6;
            transition: transform 0.1s;
        }

        .global-retreat-btn:active {
            transform: translateY(3px);
            box-shadow: 0 0 0 #95a5a6;
        }
    </style>
</head>

<body>

    <div id="start-screen">
        <h1>CEP ƒ∞MPARATORLUƒûU</h1>
        <p>Bayraklarƒ± dik, ordunu topla ve fethet!</p>
        <button id="start-btn" class="big-btn" onclick="startGame()">SAVA≈ûA BA≈ûLA</button>
        <p style="font-size:12px; margin-top:20px; color:#95a5a6;">S√ºr√ºkle: Kaydƒ±r ‚Ä¢ Dokun: Se√ß/Emir Ver</p>
    </div>

    <div id="restart-overlay">
        <h1 id="game-over-title">OYUN Bƒ∞TTƒ∞</h1>
        <p id="game-over-msg">Krallƒ±k d√º≈üt√º...</p>
        <button class="big-btn" onclick="resetGame()">TEKRAR OYNA</button>
    </div>

    <div id="ui-layer">
        <div id="resources">
            <div class="res-item"><span class="res-icon">ü•©</span><span id="res-food">3000</span></div>
            <div class="res-item"><span class="res-icon">ü™µ</span><span id="res-wood">3000</span></div>
            <div class="res-item"><span class="res-icon">ü™ô</span><span id="res-gold">3000</span></div>
            <div class="res-item"><span class="res-icon">üè†</span><span id="res-pop">0/20</span></div>
        </div>

        <div id="global-commands">
            <!-- YENƒ∞ BUTON: Acil Geri √áekilme -->
            <div class="global-retreat-btn" onclick="commandArmy('retreat', true)" title="T√ºm Birlikleri Acil Geri √áek">
                üè≥Ô∏è</div>

            <div id="zoom-controls">
                <div class="zoom-btn" onclick="changeZoom(0.1)">+</div>
                <div class="zoom-btn" onclick="changeZoom(-0.1)">-</div>
            </div>
        </div>

        <div id="notifications"></div>
        <div id="selection-info"></div>

        <div id="bottom-panel"></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const CANVAS = document.getElementById('gameCanvas');
        const CTX = CANVAS.getContext('2d');

        let SCREEN_W = window.innerWidth;
        let SCREEN_H = window.innerHeight;
        CANVAS.width = SCREEN_W;
        CANVAS.height = SCREEN_H;

        const WORLD_W = 3000;
        const WORLD_H = 3000;
        const TILE_SIZE = 40;

        let camera = { x: 0, y: 0 };
        let zoomLevel = 1.0;

        // BA≈ûLANGI√á KAYNAKLARI: 3000
        let resources = { food: 3000, wood: 3000, gold: 3000, pop: 0, maxPop: 20 };

        let entities = [];
        let projectiles = [];
        let particles = [];
        let floatTexts = [];

        let selectedEntities = [];
        let buildingMode = null;
        let wallStartPoint = null;
        let clickMarker = null;
        let isGameOver = false;

        let lastClickTime = 0;
        let clickCount = 0;
        let lastClickedType = null;
        let gameStarted = false;

        // Orduya genel saldƒ±rƒ± hedefi (Enemy TC)
        let armyObjective = null;

        // Ses motoru iptal edildi.
        function playSound(frequency, duration, type = 'sine', volume = 0.1) {
            // Ses efektleri devre dƒ±≈üƒ± bƒ±rakƒ±ldƒ±.
        }

        // ƒ∞nterval ve Animasyon ID'leri
        let enemyAiInterval = null;
        let enemyBuildInterval = null;
        let limitInterval = null;
        let gameLoopId = null;

        const TEAM_PLAYER = 1;
        const TEAM_ENEMY = 2;
        const TEAM_NATURE = 0;

        const COLORS = {
            [TEAM_PLAYER]: '#3498db',
            [TEAM_ENEMY]: '#e74c3c',
            [TEAM_NATURE]: '#95a5a6'
        };

        // Kaynak Yenileme Fonksiyonu (Bildirimsiz)
        function spawnResource(type) {
            let attempts = 0;
            let newX, newY;
            const minResourceDistance = 150;
            const minBaseDistance = 500;

            const playerTC = entities.find(e => e.team === TEAM_PLAYER && e.type === 'towncenter');

            while (attempts < 50) {
                newX = Math.random() * WORLD_W;
                newY = Math.random() * WORLD_H;

                // Oyuncu merkezine √ßok yakƒ±n olmamalƒ±
                if (playerTC && getDist({ x: newX, y: newY }, playerTC) < minBaseDistance) {
                    attempts++;
                    continue;
                }

                // Diƒüer kaynaklara veya yapƒ±lara √ßok yakƒ±n olmamalƒ±
                let overlap = entities.some(e =>
                    (e.team === TEAM_NATURE || e.type === 'towncenter') && getDist({ x: newX, y: newY }, e) < minResourceDistance
                );

                if (!overlap) {
                    entities.push(new Entity(newX, newY, type, TEAM_NATURE));
                    // T√ºm kaynaklar bildirimsiz yenilenir
                    return;
                }
                attempts++;
            }
        }


        class Projectile {
            constructor(x, y, target, damage) {
                this.x = x; this.y = y; this.target = target; this.damage = damage;
                this.speed = 10; this.life = 60;
                const dx = target.x - x; const dy = target.y - y; const dist = Math.sqrt(dx * dx + dy * dy);
                this.vx = (dx / dist) * this.speed; this.vy = (dy / dist) * this.speed; this.angle = Math.atan2(dy, dx);
            }
            update() {
                this.x += this.vx; this.y += this.vy; this.life--;
                if (this.target && this.target.hp > 0) {
                    const dist = Math.sqrt((this.x - this.target.x) ** 2 + (this.y - this.target.y) ** 2);
                    if (dist < this.target.radius + 5) {
                        this.target.hp -= this.damage;
                        createParticles(this.target.x, this.target.y, '#c0392b', 2);
                        return false;
                    }
                }
                return this.life > 0;
            }
        }

        function drawTower(ctx, color, progress, entity) {
            ctx.fillStyle = '#7f8c8d'; ctx.fillRect(-15, -30, 30, 60);
            ctx.fillStyle = '#555'; ctx.beginPath(); ctx.moveTo(-20, -30); ctx.lineTo(20, -30); ctx.lineTo(0, -50); ctx.fill();
            ctx.fillStyle = '#2c3e50'; ctx.fillRect(-5, -20, 10, 15);
            if (progress < 100) { drawScaffold(ctx, 30, 60, progress); return; }
            ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0, -50); ctx.lineTo(0, -65); ctx.stroke();
            ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(0, -75); ctx.lineTo(15, -70); ctx.lineTo(0, -65); ctx.fill();
        }

        function drawFarm(ctx, progress) {
            ctx.fillStyle = '#5d4037'; ctx.fillRect(-20, -20, 40, 40);
            ctx.strokeStyle = '#3e2723'; ctx.lineWidth = 2;
            for (let i = -15; i < 20; i += 10) { ctx.beginPath(); ctx.moveTo(-18, i); ctx.lineTo(18, i); ctx.stroke(); }
            if (progress >= 100) {
                ctx.fillStyle = '#2ecc71'; for (let x = -15; x < 15; x += 10) { for (let y = -15; y < 15; y += 10) { ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI * 2); ctx.fill(); } }
            } else { drawScaffold(ctx, 40, 40, progress); }
        }

        function drawArcheryRange(ctx, color, progress) {
            ctx.fillStyle = '#7f8c8d'; ctx.fillRect(-25, -25, 50, 50);
            if (progress < 100) { drawScaffold(ctx, 50, 50, progress); return; }
            ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(-10, 0, 8, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#e74c3c'; ctx.beginPath(); ctx.arc(-10, 0, 5, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(-10, 0, 2, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#5d4037'; ctx.fillRect(10, -15, 5, 30);
        }

        // D√∂n√º≈üt√ºrme Merkezi √áizimi
        function drawConversionCenter(ctx, color, progress) {
            const w = 60;
            const h = 45;

            // G√∂lge
            ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.beginPath(); ctx.ellipse(0, h / 2, w / 1.5, h / 4, 0, 0, Math.PI * 2); ctx.fill();

            if (progress < 100) {
                drawScaffold(ctx, w, h, progress);
                return;
            }

            // Temel (Ta≈ü/Tuƒüla)
            ctx.fillStyle = '#6d4c41';
            ctx.fillRect(-w / 2, -h / 2 + 20, w, h - 20);

            // Baca/Fƒ±rƒ±n (Metal/Gri)
            ctx.fillStyle = '#7f8c8d';
            ctx.fillRect(-10, -h / 2, 20, 30);

            // D√∂n√º≈ü√ºm ƒ∞konu - √ústte Altƒ±n Sikke
            ctx.fillStyle = '#f1c40f';
            ctx.beginPath();
            ctx.arc(0, -h / 2 - 5, 7, 0, Math.PI * 2); // Coin icon
            ctx.fill();
            ctx.strokeStyle = '#f39c12';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-3, -h / 2 - 8);
            ctx.lineTo(3, -h / 2 - 8);
            ctx.stroke();
        }

        function drawHeavyCavalry(ctx, color, type) { // Yeni type parametresi eklendi
            const isHeroCavalry = type === 'herocavalry';

            ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.beginPath(); ctx.ellipse(0, 18, 16, 6, 0, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#2c3e50'; ctx.beginPath(); ctx.ellipse(0, 8, 16, 9, 0, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.stroke();
            ctx.save(); ctx.rotate(-0.6);
            ctx.fillStyle = '#34495e'; ctx.beginPath(); ctx.ellipse(-12, 12, 7, 13, 0, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#95a5a6'; ctx.beginPath(); ctx.moveTo(-12, 5); ctx.lineTo(-8, 20); ctx.lineTo(-16, 20); ctx.fill(); ctx.restore();
            ctx.fillStyle = '#2c3e50'; ctx.fillRect(-12, 12, 5, 12); ctx.fillRect(-7, 14, 5, 10); ctx.fillRect(7, 12, 5, 12); ctx.fillRect(11, 14, 5, 10);
            ctx.save(); ctx.translate(0, -4);

            // Hero Cavalry specific coloring
            ctx.fillStyle = isHeroCavalry ? '#1c1c1c' : '#7f8c8d'; // Darker Armor for Guards
            ctx.fillRect(-6, -12, 12, 14);
            ctx.fillStyle = isHeroCavalry ? '#f1c40f' : color; // Gold/Team Stripe
            ctx.fillRect(-3, -12, 6, 14);

            ctx.fillStyle = '#95a5a6'; ctx.beginPath(); ctx.arc(0, -16, 5, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0, -21); ctx.lineTo(0, -26); ctx.stroke();

            // Lancer/Strong Spear visual for Hero Cavalry
            ctx.strokeStyle = isHeroCavalry ? '#f1c40f' : '#bdc3c7'; // Gold Lance or Silver
            ctx.lineWidth = isHeroCavalry ? 3 : 2;
            ctx.beginPath(); ctx.moveTo(6, -6); ctx.lineTo(25, 10); ctx.stroke();
            ctx.fillStyle = isHeroCavalry ? '#f39c12' : '#e74c3c'; // Stronger tip
            ctx.beginPath(); ctx.moveTo(25, 10); ctx.lineTo(30, 12); ctx.lineTo(24, 13); ctx.fill();
            ctx.restore();
        }

        function drawHuman(ctx, color, type, actionState) {
            const isSoldier = type === 'soldier';
            const isArcher = type === 'archer';
            const isSpecial = type === 'special_villager';
            const isPikeman = type === 'pikeman';
            const isHealer = type === 'healer';

            // YENƒ∞ Bƒ∞Rƒ∞MLER
            const isHeavyInfantry = type === 'heavy_infantry';
            const isSiegeEngineer = type === 'siege_engineer';
            const isCrossbowman = type === 'crossbowman';
            const isGuard = type === 'castle_guard'; // Muhafƒ±z
            const isShieldman = type === 'shieldman'; // Kalkan Sava≈ü√ßƒ±sƒ±
            const isBerserker = type === 'berserker'; // Berserker

            ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.beginPath(); ctx.ellipse(0, 5, 8, 3, 0, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#2c3e50'; ctx.fillRect(-4, 0, 3, 8); ctx.fillRect(1, 0, 3, 8);

            // G√∂vde ve Zƒ±rh
            if (isSoldier || isArcher || isPikeman || isHeavyInfantry || isSiegeEngineer || isCrossbowman || isGuard || isShieldman || isBerserker) {
                // Birime g√∂re zƒ±rh rengi
                let armorColor = '#7f8c8d';
                if (isGuard) armorColor = '#1a252f';
                else if (isHeavyInfantry) armorColor = '#34495e';
                else if (isSiegeEngineer) armorColor = '#d35400';
                else if (isShieldman) armorColor = '#2c3e50'; // Koyu mavi zƒ±rh
                else if (isBerserker) armorColor = '#8e44ad'; // Mor zƒ±rh

                ctx.fillStyle = armorColor;
                ctx.fillRect(-8, -12, 16, 14);
                ctx.fillStyle = isGuard ? '#f1c40f' : (isBerserker ? '#e74c3c' : color); // Muhafƒ±zlar altƒ±n, Berserker kƒ±rmƒ±zƒ±
                ctx.fillRect(-4, -10, 8, 12);
            } else {
                // K√∂yl√º, √ñzel K√∂yl√º veya ≈ûifacƒ±
                ctx.fillStyle = isSpecial ? '#8e44ad' : (isHealer ? '#2ecc71' : color);
                ctx.fillRect(-5, -9, 10, 10);
            }

            // Kafa
            ctx.fillStyle = '#ffccaa'; ctx.beginPath(); ctx.arc(0, -15, 5, 0, Math.PI * 2); ctx.fill();

            // √ñzelle≈ümi≈ü S√ºs/Silah/ƒ∞kon
            if (isSpecial) {
                ctx.fillStyle = '#f1c40f'; ctx.fillRect(-4, -20, 8, 2); // Ta√ß
            }

            if (isGuard) {
                ctx.fillStyle = '#555'; ctx.beginPath(); ctx.arc(0, -17, 5.5, Math.PI, 0); ctx.fill(); // Gri Kask
                ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(6, -8); ctx.lineTo(18, 5); ctx.stroke(); // Altƒ±n Kƒ±lƒ±√ß
            } else if (isHeavyInfantry) {
                ctx.fillStyle = '#555'; ctx.beginPath(); ctx.arc(0, -17, 5.5, Math.PI, 0); ctx.fill(); // Aƒüƒ±r Kask
                ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(6, -8); ctx.lineTo(18, 5); ctx.stroke(); // Baltalƒ± Silah
            } else if (isSiegeEngineer) {
                ctx.fillStyle = '#1c1c1c'; ctx.beginPath(); ctx.arc(0, -17, 5.5, 0, Math.PI * 2); ctx.fill(); // Kask
                ctx.fillStyle = '#d35400'; ctx.fillRect(5, -10, 10, 5); // Patlayƒ±cƒ±
                ctx.fillStyle = '#f1c40f'; ctx.fillRect(15, -10, 3, 5); // F√ºnye
            } else if (isCrossbowman) {
                ctx.fillStyle = '#5d4037'; ctx.fillRect(-10, -18, 20, 3); // Kap≈üon
                ctx.strokeStyle = '#3e2723'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(15, -5); ctx.stroke(); // Arbalet G√∂vdesi
                ctx.beginPath(); ctx.moveTo(15, -10); ctx.lineTo(15, 0); ctx.stroke(); // Yay gergi
            }
            else if (isArcher) {
                ctx.fillStyle = '#27ae60'; ctx.beginPath(); ctx.moveTo(-5, -16); ctx.lineTo(5, -16); ctx.lineTo(0, -22); ctx.fill();
                ctx.strokeStyle = '#d35400'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(6, -6, 8, 1.5, 4.5); ctx.stroke();
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 0.5; ctx.beginPath(); ctx.moveTo(6, -14); ctx.lineTo(6, 2); ctx.stroke();
            } else if (isSoldier) {
                ctx.fillStyle = '#95a5a6'; ctx.beginPath(); ctx.arc(0, -14, 4.5, Math.PI, 0); ctx.fill();
                ctx.fillStyle = color; ctx.beginPath(); ctx.arc(-6, -4, 5, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = '#bdc3c7'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(6, -5); ctx.lineTo(14, 2); ctx.stroke();
            } else if (isPikeman) {
                // Mƒ±zrak (Pike)
                ctx.strokeStyle = '#bdc3c7'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(6, -5); ctx.lineTo(25, 15); ctx.stroke();
                ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.moveTo(25, 15); ctx.lineTo(30, 10); ctx.lineTo(24, 10); ctx.fill();
                ctx.strokeStyle = color; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, -18); ctx.lineTo(0, -22); ctx.stroke();
            } else if (isHealer) {
                // ≈ûifacƒ± ƒ∞konu (Ha√ß)
                ctx.strokeStyle = '#ecf0f1';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-4, -18); ctx.lineTo(4, -18); ctx.moveTo(0, -22); ctx.lineTo(0, -14);
                ctx.stroke();
            } else if (isShieldman) {
                // Kalkan Sava≈ü√ßƒ±sƒ± - B√ºy√ºk Kalkan + Topuz
                ctx.fillStyle = '#f39c12'; // Altƒ±n kalkan
                ctx.beginPath();
                ctx.ellipse(-10, -2, 8, 12, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#d35400'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.ellipse(-10, -2, 8, 12, 0, 0, Math.PI * 2); ctx.stroke();
                // Kalkan detayƒ±
                ctx.strokeStyle = '#e67e22'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(-10, -14); ctx.lineTo(-10, 10); ctx.stroke();
                // Topuz (Mace)
                ctx.strokeStyle = '#7f8c8d'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(5, -8); ctx.lineTo(15, 0); ctx.stroke();
                ctx.fillStyle = '#555'; ctx.beginPath(); ctx.arc(15, 0, 5, 0, Math.PI * 2); ctx.fill();
                // Kask
                ctx.fillStyle = '#95a5a6'; ctx.beginPath(); ctx.arc(0, -17, 6, Math.PI, 0); ctx.fill();
            } else if (isBerserker) {
                // Berserker - √áift Balta + Sava≈ü Boyasƒ±
                // Kƒ±rmƒ±zƒ± sava≈ü boyasƒ± (y√ºzde)
                ctx.fillStyle = '#c0392b';
                ctx.beginPath(); ctx.moveTo(-3, -18); ctx.lineTo(3, -18); ctx.lineTo(2, -14); ctx.lineTo(-2, -14); ctx.fill();
                // √áift balta
                ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(-8, -10); ctx.lineTo(-18, 5); ctx.stroke(); // Sol balta sapƒ±
                ctx.beginPath(); ctx.moveTo(8, -10); ctx.lineTo(18, 5); ctx.stroke(); // Saƒü balta sapƒ±
                // Balta ba≈ülarƒ±
                ctx.fillStyle = '#bdc3c7';
                ctx.beginPath(); ctx.moveTo(-18, 5); ctx.lineTo(-22, 0); ctx.lineTo(-18, -2); ctx.lineTo(-14, 5); ctx.fill();
                ctx.beginPath(); ctx.moveTo(18, 5); ctx.lineTo(22, 0); ctx.lineTo(18, -2); ctx.lineTo(14, 5); ctx.fill();
            }

            // K√∂yl√º Aksiyonlarƒ± 
            if (type === 'villager' || type === 'special_villager') {
                if (actionState === 'wood') { ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(-6, -5); ctx.lineTo(6, -5); ctx.stroke(); }
                else if (actionState === 'farm') { ctx.fillStyle = '#2ecc71'; ctx.beginPath(); ctx.arc(5, -2, 4, 0, Math.PI * 2); ctx.fill(); }
            }
        }

        function drawHero(ctx, color) {
            ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.beginPath(); ctx.ellipse(0, 8, 12, 5, 0, 0, Math.PI * 2); ctx.fill();

            // Siyah Pelerin (Black Cloak)
            ctx.fillStyle = '#1c1c1c';
            ctx.beginPath();
            ctx.moveTo(-10, -10); // Sol √ºst omuz
            ctx.lineTo(10, -10);  // Saƒü √ºst omuz
            ctx.lineTo(15, 10);   // Saƒü alt k√∂≈üe (hafif geni≈ü)
            ctx.lineTo(-15, 10);  // Sol alt k√∂≈üe (hafif geni≈ü)
            ctx.closePath();
            ctx.fill();

            // Zƒ±rh (Kralƒ±n g√∂vdesi)
            ctx.fillStyle = '#f1c40f'; ctx.fillRect(-6, -12, 12, 14);

            // Kafa ve Ta√ß
            ctx.fillStyle = '#ffccaa'; ctx.beginPath(); ctx.arc(0, -16, 5, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#f39c12'; ctx.beginPath(); ctx.moveTo(-6, -18); ctx.lineTo(0, -24); ctx.lineTo(6, -18); ctx.fill();

            // Silah
            ctx.strokeStyle = '#ecf0f1'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(8, -8); ctx.lineTo(20, 5); ctx.stroke();
        }

        // MANCINIK √áƒ∞Zƒ∞Mƒ∞
        function drawCatapult(ctx, color) {
            // G√∂lge
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.beginPath();
            ctx.ellipse(0, 15, 25, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Tekerlekler
            ctx.fillStyle = '#5d4037';
            ctx.beginPath(); ctx.arc(-15, 10, 8, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(15, 10, 8, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = '#3e2723'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(-15, 10, 8, 0, Math.PI * 2); ctx.stroke();
            ctx.beginPath(); ctx.arc(15, 10, 8, 0, Math.PI * 2); ctx.stroke();

            // Ana g√∂vde (Ah≈üap √ßer√ßeve)
            ctx.fillStyle = '#8d6e63';
            ctx.fillRect(-20, -5, 40, 15);

            // Fƒ±rlatma kolu
            ctx.strokeStyle = '#6d4c41'; ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(-15, -30); ctx.stroke();

            // Kaya (Mermi)
            ctx.fillStyle = '#7f8c8d';
            ctx.beginPath(); ctx.arc(-15, -35, 8, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#95a5a6';
            ctx.beginPath(); ctx.arc(-13, -37, 3, 0, Math.PI * 2); ctx.fill();

            // Takƒ±m rengi bayrak
            ctx.fillStyle = color;
            ctx.beginPath(); ctx.moveTo(20, -5); ctx.lineTo(20, -20); ctx.lineTo(30, -15); ctx.lineTo(20, -10); ctx.fill();
        }

        function drawBuilding(ctx, type, color, progress, entity) {
            if (type === 'wall') {
                ctx.fillStyle = '#555'; ctx.fillRect(-20, -20, 40, 40);
                ctx.strokeStyle = '#333'; ctx.lineWidth = 1; ctx.strokeRect(-20, -20, 20, 20); ctx.strokeRect(0, 0, 20, 20);
                if (progress < 100) drawScaffold(ctx, 40, 40, progress); return;
            }
            if (type === 'tower') { drawTower(ctx, color, progress, entity); return; }
            if (type === 'farm') { drawFarm(ctx, progress); return; }
            if (type === 'archery_range') { drawArcheryRange(ctx, color, progress); return; }
            if (type === 'conversion_center') { drawConversionCenter(ctx, color, progress); return; }

            ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.beginPath();
            let w = 40, h = 40; if (type === 'towncenter') { w = 60; h = 50; }
            ctx.ellipse(0, h / 2, w / 1.5, h / 4, 0, 0, Math.PI * 2); ctx.fill();
            if (progress < 100) { drawScaffold(ctx, w, h, progress); return; }

            if (type === 'house') {
                ctx.fillStyle = '#d7ccc8'; ctx.fillRect(-15, -15, 30, 25);
                ctx.fillStyle = '#3e2723'; ctx.fillRect(-5, 0, 10, 10);
                ctx.fillStyle = color === COLORS[TEAM_PLAYER] ? '#2980b9' : '#c0392b';
                ctx.beginPath(); ctx.moveTo(-20, -15); ctx.lineTo(0, -35); ctx.lineTo(20, -15); ctx.fill();
            } else if (type === 'towncenter') {
                ctx.fillStyle = '#7f8c8d'; ctx.fillRect(-30, -10, 60, 30);
                ctx.fillStyle = '#a1887f'; ctx.fillRect(-25, -30, 50, 20);
                ctx.fillStyle = color === COLORS[TEAM_PLAYER] ? '#2980b9' : '#c0392b';
                ctx.beginPath(); ctx.moveTo(-35, -30); ctx.lineTo(0, -55); ctx.lineTo(35, -30); ctx.fill();
                ctx.strokeStyle = '#fff'; ctx.beginPath(); ctx.moveTo(0, -55); ctx.lineTo(0, -75); ctx.stroke();
                ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(0, -75); ctx.lineTo(15, -70); ctx.lineTo(0, -65); ctx.fill();
            } else if (type === 'barracks') {
                ctx.fillStyle = '#5d4037'; ctx.fillRect(-25, -20, 50, 40);
                ctx.fillStyle = '#3e2723'; ctx.beginPath(); ctx.moveTo(-30, -20); ctx.lineTo(30, -20); ctx.lineTo(20, -35); ctx.lineTo(-20, -35); ctx.fill();
            }
        }

        function drawScaffold(ctx, w, h, progress) {
            ctx.strokeStyle = '#8d6e63'; ctx.lineWidth = 2;
            ctx.strokeRect(-w / 2, -h / 2, w, h);
            ctx.beginPath(); ctx.moveTo(-w / 2, -h / 2); ctx.lineTo(w / 2, h / 2); ctx.stroke();
            ctx.fillStyle = '#3498db'; ctx.fillRect(-w / 2, -h / 2 - 10, w * (progress / 100), 5);
        }

        function drawResource(ctx, type) {
            ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.beginPath(); ctx.ellipse(0, 5, 10, 4, 0, 0, Math.PI * 2); ctx.fill();
            if (type === 'tree') {
                ctx.fillStyle = '#5d4037'; ctx.fillRect(-3, 0, 6, 10);
                ctx.fillStyle = '#2e7d32'; ctx.beginPath(); ctx.moveTo(-15, 0); ctx.lineTo(0, -20); ctx.lineTo(15, 0); ctx.fill();
                ctx.fillStyle = '#388e3c'; ctx.beginPath(); ctx.moveTo(-12, -10); ctx.lineTo(0, -30); ctx.lineTo(12, -10); ctx.fill();
                ctx.fillStyle = '#4caf50'; ctx.beginPath(); ctx.moveTo(-8, -20); ctx.lineTo(0, -35); ctx.lineTo(8, -20); ctx.fill();
            } else if (type === 'gold_mine') {
                ctx.fillStyle = '#757575'; ctx.beginPath(); ctx.moveTo(-15, 10); ctx.lineTo(-10, -10); ctx.lineTo(5, -15); ctx.lineTo(15, 5); ctx.lineTo(5, 15); ctx.fill();
                ctx.fillStyle = '#ffca28'; ctx.beginPath(); ctx.arc(-5, 0, 3, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(5, -5, 4, 0, Math.PI * 2); ctx.fill();
            } else if (type === 'bush') {
                ctx.fillStyle = '#43a047'; ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(-8, 5, 8, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(8, 5, 8, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#e53935'; ctx.beginPath(); ctx.arc(-5, 0, 3, 0, Math.PI * 2); ctx.fill();
            }
        }

        function getMyVillagerCount() {
            return entities.filter(e => (e.type === 'villager' || e.type === 'special_villager') && e.team === TEAM_PLAYER).length;
        }

        class Entity {
            constructor(x, y, type, team) {
                this.id = Math.random().toString(36).substr(2, 9);
                this.x = x; this.y = y; this.type = type; this.team = team;
                this.radius = 15; this.hp = 100; this.maxHp = 100;
                this.state = 'idle'; this.target = null; this.gatherType = null;
                this.carrying = 0; this.maxCarry = 25;
                this.attackRange = 25; this.visionRange = 300; this.attackDmg = 5;
                this.speed = 0; this.timer = 0; this.constructionProgress = 100; this.idleTimer = 0;
                this.rallyPoint = null;
                this.isAutoWorker = false;
                this.isRetreating = false;
                this.retreatTarget = null; // YENƒ∞: Geri √ßekilme hedefi
                this.guarding = null;
                this.isGuard = false; // YENƒ∞: Kale Muhafƒ±zƒ± bayraƒüƒ±
                this.guardPost = null; // YENƒ∞: Muhafƒ±z postu konumu

                // Birim Temel Statlarƒ± (Oyuncu Statlarƒ±)
                if (type === 'villager') { this.speed = 2.2; this.maxCarry = 25; }
                else if (type === 'special_villager') {
                    this.speed = 3.0; this.maxCarry = 50; this.hp = 150; this.maxHp = 150;
                }
                else if (type === 'soldier') { this.speed = 2.2; this.attackDmg = 15; this.maxHp = 120; this.hp = 120; }
                else if (type === 'archer') { this.speed = 2.0; this.attackDmg = 10; this.maxHp = 80; this.hp = 80; this.attackRange = 180; }
                else if (type === 'cavalry') { this.speed = 3.5; this.attackDmg = 35; this.maxHp = 300; this.hp = 300; this.radius = 20; }
                else if (type === 'pikeman') {
                    this.speed = 2.0; this.attackDmg = 20; this.maxHp = 150; this.hp = 150; this.attackRange = 40;
                }
                else if (type === 'healer') {
                    this.speed = 2.8; this.attackDmg = 0; this.maxHp = 80; this.hp = 80; this.attackRange = 0; this.healingRange = 100; this.healingPower = 5;
                }
                // Hero g√º√ßlendirildi
                else if (type === 'hero') {
                    this.speed = 3.0;
                    this.attackDmg = 200;
                    this.maxHp = 7500;
                    this.hp = 7500;
                    this.radius = 25; this.visionRange = 500;
                }
                // Hero S√ºvari Korumasƒ± (ƒ∞ki Atlƒ±)
                else if (type === 'herocavalry') {
                    this.speed = 4.0;
                    this.attackDmg = 150;
                    this.maxHp = 1000;
                    this.hp = 1000;
                    this.radius = 20;
                    this.visionRange = 350;
                    this.attackRange = 40;
                }

                // YENƒ∞ ASKERLERƒ∞N STATLARI
                else if (type === 'heavy_infantry') {
                    this.speed = 1.8; this.attackDmg = 25; this.maxHp = 200; this.hp = 200; this.radius = 18;
                }
                else if (type === 'siege_engineer') {
                    this.speed = 2.5; this.attackDmg = 5; this.attackDmgBuilding = 50; this.maxHp = 60; this.hp = 60;
                    this.attackRange = 100;
                }
                else if (type === 'crossbowman') {
                    this.speed = 1.6; this.attackDmg = 40; this.maxHp = 90; this.hp = 90;
                    this.attackRange = 200;
                }
                // YENƒ∞: Kale Muhafƒ±zƒ± Statlarƒ±
                else if (type === 'castle_guard') {
                    this.speed = 2.0; this.attackDmg = 30; this.maxHp = 250; this.hp = 250;
                    this.radius = 18; this.visionRange = 350;
                    this.isGuard = true;
                    this.guardPost = { x: x, y: y }; // Ba≈ülangƒ±√ß pozisyonu postu
                }
                // MANCINIK (Catapult) - Kaya atan ku≈üatma birimi
                else if (type === 'catapult') {
                    this.speed = 1.0; this.attackDmg = 15; this.attackDmgBuilding = 120;
                    this.maxHp = 150; this.hp = 150;
                    this.radius = 25; this.attackRange = 350; this.visionRange = 400;
                }
                // KALKAN SAVA≈û√áISI (Shieldman) - Dayanƒ±klƒ± savunma birimi
                else if (type === 'shieldman') {
                    this.speed = 1.5; this.attackDmg = 12; this.maxHp = 350; this.hp = 350;
                    this.radius = 18; this.attackRange = 30;
                }
                // BERSERKER - Y√ºksek hasarlƒ± saldƒ±rƒ± birimi
                else if (type === 'berserker') {
                    this.speed = 2.8; this.attackDmg = 45; this.maxHp = 120; this.hp = 120;
                    this.radius = 16; this.attackRange = 28;
                }

                // Varsayƒ±lan saldƒ±rƒ± hƒ±zƒ± (Zamanlayƒ±cƒ± e≈üiƒüi)
                let defaultAttackSpeed = 50;
                if (this.attackRange > 30) defaultAttackSpeed = 80; // Menzilli birimler daha yava≈ü vurur

                if (type === 'crossbowman') this.attackSpeed = 150; // Arbalet√ßi, yava≈ü atƒ±≈ü hƒ±zƒ±
                else if (type === 'heavy_infantry') this.attackSpeed = 60; // Aƒüƒ±r Piyade, biraz yava≈ü
                else if (type === 'siege_engineer') this.attackSpeed = 70; // Ku≈üatma M√ºhendisi
                else if (type === 'castle_guard') this.attackSpeed = 55; // Muhafƒ±z
                else if (type === 'catapult') this.attackSpeed = 200; // Mancƒ±nƒ±k, √ßok yava≈ü ama g√º√ßl√º
                else if (type === 'shieldman') this.attackSpeed = 70; // Kalkan Sava≈ü√ßƒ±sƒ±
                else if (type === 'berserker') this.attackSpeed = 35; // Berserker, hƒ±zlƒ± saldƒ±rƒ±
                else this.attackSpeed = defaultAttackSpeed;


                // D√º≈üman Birim G√º√ßlendirmesi (D√º≈üman birimleri i√ßin yeni statlar eklendi)
                if (this.team === TEAM_ENEMY) {
                    if (this.type === 'soldier') { this.maxHp = 145; this.hp = 145; this.attackDmg = 18; }
                    else if (this.type === 'archer') { this.maxHp = 100; this.hp = 100; this.attackDmg = 12; }
                    else if (this.type === 'pikeman') { this.maxHp = 180; this.hp = 180; this.attackDmg = 24; }
                    else if (this.type === 'cavalry') { this.maxHp = 360; this.hp = 360; this.attackDmg = 42; }
                    else if (this.type === 'heavy_infantry') { this.maxHp = 250; this.hp = 250; this.attackDmg = 30; } // D√º≈üman Aƒüƒ±r Piyade
                    else if (this.type === 'crossbowman') { this.maxHp = 110; this.hp = 110; this.attackDmg = 45; } // D√º≈üman Arbalet√ßi
                    else if (this.type === 'tower') { this.maxHp = 1200; this.hp = 1200; this.attackDmg = 15; }
                }

                // Bina Statlarƒ±
                if (type === 'towncenter') { this.radius = 45; this.hp = 3000; this.maxHp = 3000; }
                if (type === 'house') { this.radius = 20; this.hp = 600; this.maxHp = 600; }
                if (type === 'barracks' || type === 'archery_range') { this.radius = 30; this.hp = 1200; this.maxHp = 1200; }
                if (type === 'wall') { this.radius = 20; this.hp = 800; this.maxHp = 800; }
                if (type === 'tower') { this.radius = 25; this.hp = 1000; this.maxHp = 1000; this.attackRange = 250; this.attackDmg = 12; }
                if (type === 'farm') { this.radius = 20; this.hp = 500; this.maxHp = 500; }
                if (type === 'conversion_center') { this.radius = 30; this.hp = 1000; this.maxHp = 1000; }
            }

            update(dt) {
                if (this.hp <= 0) {
                    createParticles(this.x, this.y, this.team === TEAM_NATURE ? '#2ecc71' : '#c0392b');
                    return false;
                }

                // ≈ûƒ∞FACI MANTIƒûI
                if (this.type === 'healer' && this.team === TEAM_PLAYER) {
                    this.timer += dt;
                    if (this.timer > 50) {
                        this.timer = 0;

                        let nearestInjured = null;
                        let minDist = this.healingRange + 1;

                        entities.forEach(e => {
                            if (e.team === TEAM_PLAYER && e.hp < e.maxHp && e.hp > 0 && e.type !== 'healer') {
                                const dist = getDist(this, e);
                                if (dist < minDist) {
                                    minDist = dist;
                                    nearestInjured = e;
                                }
                            }
                        });

                        if (nearestInjured && minDist < this.healingRange) {
                            nearestInjured.hp += this.healingPower;
                            if (nearestInjured.hp > nearestInjured.maxHp) {
                                nearestInjured.hp = nearestInjured.maxHp;
                            }
                            createParticles(nearestInjured.x, nearestInjured.y - nearestInjured.radius, '#3498db', 1); // Mavi iyile≈ütirme efekti
                        }
                    }
                }

                // Hero Koruma Birimi Takip ve Koruma Mantƒ±ƒüƒ± (herocavalry i√ßin)
                if (this.type === 'herocavalry' && this.guarding && this.team === TEAM_PLAYER) {
                    const hero = this.guarding;

                    // 1. Tehdit Kontrol√º: G√∂r√º≈ü alanƒ±nda d√º≈üman birim veya kule var mƒ±?
                    const immediateThreat = findNearestEnemyThreat(this);
                    if (immediateThreat && getDist(this, immediateThreat) < this.visionRange) {
                        this.target = immediateThreat;
                        this.state = 'attack';
                    }
                    // 2. Hero'nun hedefini benimse (Hero'ya yakƒ±nsa)
                    else if (hero.state === 'attack' && hero.target && getDist(this, hero) < 200) {
                        this.target = hero.target;
                        this.state = 'attack';
                    }
                    // 3. Hero'yu takip et
                    else if (getDist(this, hero) > 50) { // 50 birimden uzakta ise Hero'ya doƒüru hareket et
                        this.target = { x: hero.x, y: hero.y };
                        this.state = 'move';
                    }
                    // 4. Bo≈üta Kal
                    else {
                        this.state = 'idle';
                        this.target = null;
                    }
                }


                // ƒ∞≈ü√ßi Zekasƒ± (Otomatik g√∂revli i≈ü√ßi bo≈üa √ßƒ±karsa yeni i≈ü arar)
                if ((this.type === 'villager' || this.type === 'special_villager') && this.state === 'idle' && this.team === TEAM_PLAYER) {
                    if (this.isAutoWorker) {
                        this.idleTimer += dt;
                        if (this.idleTimer > 60) { this.findBestTask(); this.idleTimer = 0; }
                    }
                }

                if (this.type === 'tower' && this.constructionProgress >= 100 && this.team !== TEAM_NATURE) {
                    this.timer += dt;
                    if (this.timer > 40) {
                        const enemy = findNearestEnemy(this);
                        if (enemy && getDist(this, enemy) < this.attackRange) {
                            projectiles.push(new Projectile(this.x, this.y - 30, enemy, this.attackDmg));
                            this.timer = 0;
                        }
                    }
                }

                // Ordu Birimi Saldƒ±rƒ±/Hareket Mantƒ±ƒüƒ± (Yeni √ñncelik Sistemi)
                const isArmyUnit = ['soldier', 'archer', 'cavalry', 'hero', 'pikeman', 'herocavalry', 'heavy_infantry', 'siege_engineer', 'crossbowman', 'castle_guard', 'catapult', 'shieldman', 'berserker'].includes(this.type);

                if (this.team !== TEAM_NATURE && isArmyUnit && this.type !== 'herocavalry') {

                    // DUVAR SALDIRISI √ñNCELƒ∞ƒûƒ∞: Eƒüer birim ≈üu an bir duvara saldƒ±rƒ±yorsa ve duvar hala hayattaysa, hedefi deƒüi≈ütirme
                    if (this.state === 'attack' && this.target && this.target.type === 'wall' && this.target.hp > 0) {
                        // Mevcut duvar hedefini koru, AI √∂ncelik sistemini tamamen atla
                        // Birim zaten menzildeyse saldƒ±racak, deƒüilse hareket edecek (a≈üaƒüƒ±daki hareket mantƒ±ƒüƒ±nda)
                        // Bu sayede birimler duvarlara ula≈ütƒ±ƒüƒ±nda onlara saldƒ±rmaya devam eder
                        // AI √∂nceliklerini atla, duvar hedefini koru
                    }
                    // 1. KALE MUHAFIZI MANTIƒûI (√ñncelik 1: Muhafƒ±zlar kendi postlarƒ±nda kalƒ±r)
                    else if (this.isGuard) {
                        const immediateThreat = findNearestEnemyThreat(this);
                        const distFromPost = getDist(this, this.guardPost);

                        // Eƒüer √ßok uzaksa (200 birim), posta geri d√∂n
                        if (distFromPost > 200) {
                            this.target = this.guardPost;
                            this.state = 'move';
                        }
                        // Eƒüer yakƒ±nda tehdit varsa, tehdide saldƒ±r
                        else if (immediateThreat && getDist(this, immediateThreat) < this.visionRange) {
                            this.target = immediateThreat;
                            this.state = 'attack';
                        }
                        // Posta √ßok yakƒ±nsa ve bo≈ütaysa dur
                        else if (distFromPost < 5) {
                            this.state = 'idle';
                            this.target = null;
                        }

                        return true; // Muhafƒ±zlar kendi mantƒ±klarƒ±nƒ± tamamlar ve diƒüer komutlarƒ± dinlemez
                    }

                    // 2. ACƒ∞L GERƒ∞ √áEKƒ∞LME MANTIƒûI (√ñncelik 2: Muhafƒ±z olmayanlar i√ßin)
                    else if (this.isRetreating && this.retreatTarget) {
                        // Geri √ßekilirken, √∂nceliƒüimiz TC'ye HAREKET etmektir.
                        // Kendi canƒ±mƒ±zƒ± tehlikeye atmamak i√ßin sadece mutlak yakƒ±n d√∂v√º≈üte kendini savun:
                        const selfDefenseRange = 35; // Sabit yakƒ±n d√∂v√º≈ü menzili (yakƒ±n d√∂v√º≈ü i√ßin)
                        const currentThreat = findNearestEnemyThreat(this);

                        if (currentThreat && getDist(this, currentThreat) < selfDefenseRange) {
                            // √áok yakƒ±nda tehdit varsa, saldƒ±rmaya zorla (self-defense)
                            this.target = currentThreat;
                            this.state = 'attack';
                        } else {
                            // Yakƒ±nda tehdit yoksa, TC'ye hareket etmeye zorla
                            // √ñnceki self-defense hedefi temizlenir ve ana hedefe (TC) d√∂n√ºl√ºr.
                            this.target = this.retreatTarget;
                            this.state = 'move';
                        }
                        // Bu komut, standart ordu AI'sƒ±nƒ± (Vision Range i√ßindeki tehditler, Toplu Saldƒ±rƒ±) tamamen atlar.
                        return true;
                    }

                    // 3. STANDART ORDU HEDEFLERƒ∞ (√ñncelik 3 & 4)
                    else {
                        const immediateThreat = findNearestEnemyThreat(this);

                        // A. Vision Range i√ßindeki tehditlere saldƒ±rma (Y√ºksek √ñncelik)
                        if (immediateThreat && getDist(this, immediateThreat) < this.visionRange) {
                            this.target = immediateThreat;
                            this.state = 'attack';
                        }
                        // B. Genel Saldƒ±rƒ± Emri Varsa (Town Center'ƒ± son hedef yapmak i√ßin)
                        else if (armyObjective) {

                            const priorityTarget = findHighestPriorityObjective(this);
                            const enemyTC = entities.find(e => e.team === TEAM_ENEMY && e.type === 'towncenter' && e.hp > 0);

                            let newTarget = null;

                            if (priorityTarget) {
                                newTarget = priorityTarget;
                            } else if (enemyTC) {
                                newTarget = enemyTC;
                            } else {
                                this.state = 'idle';
                                this.target = null;
                                return true;
                            }

                            this.target = newTarget;
                            this.state = 'attack';
                        }
                        // C. Hi√ßbir komut yoksa veya hedef √∂ld√ºyse bo≈üa d√º≈ü
                        else if (this.state === 'attack' && this.target && this.target.hp <= 0) {
                            this.state = 'idle';
                            this.target = null;
                        }
                    }

                    // Ordu Hedefinin Yok Edilmesi Kontrol√º
                    if (armyObjective && armyObjective.targetEntity && armyObjective.targetEntity.hp <= 0) {
                        armyObjective = null;
                        notify("D√º≈üman Kalesi Yƒ±kƒ±ldƒ±! Ordu Bo≈üa √áƒ±ktƒ±.");
                    }

                    // Hareket ve √áarpƒ±≈üma Mantƒ±ƒüƒ±
                    if ((this.state === 'move' || (this.target && this.state !== 'idle'))) {
                        let tx = this.target ? this.target.x : this.moveX;
                        let ty = this.target ? this.target.y : this.moveY;
                        if (this.state === 'move' && this.target && this.target.x !== undefined) { tx = this.target.x; ty = this.target.y; }
                        const dx = tx - this.x; const dy = ty - this.y; const dist = Math.sqrt(dx * dx + dy * dy);
                        let stopDist = 5;
                        if (this.target && this.state !== 'move') {
                            stopDist = this.attackRange;
                            if (['gather', 'build'].includes(this.state)) stopDist = 35;
                            if (this.target.radius) stopDist += this.target.radius;
                        }
                        if (dist > stopDist) {
                            const angle = Math.atan2(dy, dx);

                            let nextX = this.x + Math.cos(angle) * this.speed * dt;
                            let nextY = this.y + Math.sin(angle) * this.speed * dt;

                            // √áarpƒ±≈üma √ñnleme (Separation Logic)
                            if (['villager', 'special_villager', 'soldier', 'archer', 'cavalry', 'hero', 'pikeman', 'healer', 'herocavalry', 'heavy_infantry', 'siege_engineer', 'crossbowman', 'castle_guard', 'catapult', 'shieldman', 'berserker'].includes(this.type)) {
                                let sepX = 0, sepY = 0;
                                for (let other of entities) {
                                    if (other !== this && other.hp > 0 && ['villager', 'special_villager', 'soldier', 'archer', 'cavalry', 'hero', 'pikeman', 'healer', 'herocavalry', 'heavy_infantry', 'siege_engineer', 'crossbowman', 'castle_guard', 'catapult', 'shieldman', 'berserker'].includes(other.type)) {
                                        let d = Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
                                        let minDist = this.radius + other.radius - 5;
                                        if (d < minDist && d > 0) {
                                            let pushForce = (minDist - d) / d;
                                            sepX += (this.x - other.x) * pushForce;
                                            sepY += (this.y - other.y) * pushForce;
                                        }
                                    }
                                }
                                nextX += sepX * 0.15;
                                nextY += sepY * 0.15;

                                let wallX = checkWallCollision(nextX, this.y, this);
                                if (wallX) { if (this.team !== wallX.team && this.team !== TEAM_NATURE) { this.state = 'attack'; this.target = wallX; } nextX = this.x; }
                                let wallY = checkWallCollision(nextX, nextY, this);
                                if (wallY) { if (this.team !== wallY.team && this.team !== TEAM_NATURE) { this.state = 'attack'; this.target = wallY; } nextY = this.y; }
                            }

                            this.x = nextX; this.y = nextY;
                        } else {
                            if (this.state === 'move') {
                                this.state = 'idle'; this.target = null;
                                this.isRetreating = false; // Geri √ßekilme bittiƒüinde bayraƒüƒ± kaldƒ±r.
                                this.retreatTarget = null; // Geri √ßekilme hedefini temizle
                            } else {
                                this.interact(dt);
                            }
                        }
                    }
                    return true;
                }

                // Ordu olmayan entity'ler i√ßin (k√∂yl√ºler, binalar, doƒüa kaynaklarƒ±)
                return true;
            }

            findBestTask() {
                // En az olan kaynaƒüa otomatik y√∂nlendirme
                let needs = [{ type: 'food', val: resources.food, targets: ['bush', 'farm'] }, { type: 'wood', val: resources.wood, targets: ['tree'] }, { type: 'gold', val: resources.gold, targets: ['gold_mine'] }];
                needs.sort((a, b) => a.val - b.val);
                for (let need of needs) {
                    let bestTarget = null; let minD = Infinity;
                    for (let e of entities) {
                        if (need.targets.includes(e.type) && e.hp > 0 && e.team === TEAM_NATURE) {
                            let dist = getDist(this, e);
                            if (dist < minD) { minD = dist; bestTarget = e; }
                        }
                        if (need.type === 'food' && e.type === 'farm' && e.team === TEAM_PLAYER && e.constructionProgress >= 100) {
                            let dist = getDist(this, e);
                            if (dist < minD) { minD = dist; bestTarget = e; }
                        }
                    }
                    if (bestTarget) {
                        this.target = bestTarget;
                        this.state = 'gather';
                        this.gatherType = bestTarget.type === 'tree' ? 'wood' : bestTarget.type === 'gold_mine' ? 'gold' : 'food';
                        return;
                    }
                }
                // Hi√ß kaynak bulamazsa bo≈üa d√º≈üer
                this.state = 'idle';
                this.target = null;
            }

            interact(dt) {
                if (this.state === 'gather' && this.target) {
                    this.timer += dt;
                    let gatherSpeed = this.type === 'special_villager' ? 20 : 40;

                    if (this.timer > gatherSpeed) {
                        this.timer = 0; createParticles(this.target.x, this.target.y, '#f1c40f', 1); this.carrying++;

                        if (this.target.type !== 'farm') {
                            this.target.hp -= 5;
                            if (this.target.hp <= 0) {
                                // Kaynak t√ºkendiƒüinde otomatik yeniden g√∂revlendir
                                const consumedTarget = this.target;

                                this.state = 'idle';
                                if (this.isAutoWorker) {
                                    this.findBestTask();
                                } else {
                                    this.target = null;
                                }

                                // Kaynak bittiƒüinde yenisini olu≈ütur (bildirimsiz)
                                if (consumedTarget.type === 'gold_mine') {
                                    spawnResource('gold_mine');
                                }
                                if (consumedTarget.type === 'tree') {
                                    spawnResource('tree');
                                }

                                return;
                            }
                        }

                        if (this.carrying >= this.maxCarry) this.returnCargo();
                    }
                } else if (this.state === 'attack' && this.target) {
                    this.timer += dt;
                    // Birimin √∂zel saldƒ±rƒ± hƒ±zƒ±nƒ± kullan
                    let attackDelay = this.attackSpeed || 50;

                    if (this.timer > attackDelay) {
                        this.timer = 0;

                        // Menzilli Birimler (Ok√ßu, Kule, Ku≈üatma M√ºhendisi, Arbalet√ßi, Mancƒ±nƒ±k)
                        if (this.type === 'archer' || this.type === 'tower' || this.type === 'siege_engineer' || this.type === 'crossbowman' || this.type === 'catapult') {
                            let dmg = this.attackDmg;

                            // Ku≈üatma M√ºhendisi veya Mancƒ±nƒ±k: Binalara y√ºksek hasar ver
                            const isTargetBuilding = this.target.type !== undefined && !['villager', 'special_villager', 'soldier', 'cavalry', 'hero', 'archer', 'pikeman', 'healer', 'herocavalry', 'crossbowman', 'heavy_infantry', 'castle_guard', 'catapult', 'shieldman', 'berserker'].includes(this.target.type);
                            if ((this.type === 'siege_engineer' || this.type === 'catapult') && isTargetBuilding) {
                                dmg = this.attackDmgBuilding; // Mancƒ±nƒ±k: 120, M√ºhendis: 50
                                createParticles(this.target.x, this.target.y, '#f39c12', 8);
                            } else if ((this.type === 'siege_engineer' || this.type === 'catapult') && !isTargetBuilding) {
                                dmg = this.attackDmg; // Birimlere d√º≈ü√ºk hasar
                            }

                            projectiles.push(new Projectile(this.x, this.y, this.target, dmg));
                        }
                        // Yakƒ±n D√∂v√º≈ü Birimleri (Shieldman ve Berserker eklendi)
                        else if (['soldier', 'cavalry', 'hero', 'pikeman', 'herocavalry', 'heavy_infantry', 'castle_guard', 'shieldman', 'berserker'].includes(this.type)) {
                            createParticles(this.target.x, this.target.y, '#c0392b', 3);
                            this.target.hp -= this.attackDmg;
                            if (this.target.hp <= 0) {

                                // Geri √áekilme Sƒ±rasƒ±nda √ñl√ºm: Tekrar TC'ye y√∂nlendir
                                if (this.isRetreating && this.retreatTarget) {
                                    this.target = this.retreatTarget;
                                    this.state = 'move';
                                } else {
                                    this.state = 'idle'; this.target = null;
                                }

                            }
                        }
                    }
                } else if (this.state === 'build' && this.target) {
                    this.timer += dt;
                    if (this.timer > 20) {
                        this.timer = 0; this.target.constructionProgress += 5; createParticles(this.target.x, this.target.y, '#bdc3c7', 1);
                        if (this.target.constructionProgress >= 100) {
                            this.target.constructionProgress = 100;
                            // ƒ∞n≈üaat bittiƒüinde, i≈ü√ßi otomatik g√∂revliyse toplama/yeni g√∂rev bulma moduna ge√ßer
                            if (this.isAutoWorker) {
                                if (this.target.type === 'farm') {
                                    this.state = 'gather';
                                    this.gatherType = 'farm';
                                } else {
                                    this.findBestTask();
                                }
                            } else {
                                this.state = 'idle';
                            }
                            updatePopulationLimit();
                        }
                    }
                } else if (this.state === 'return') {
                    if (this.gatherType === 'wood') resources.wood += this.carrying; if (this.gatherType === 'food' || this.gatherType === 'farm') resources.food += this.carrying; if (this.gatherType === 'gold') resources.gold += this.carrying;
                    showFloatText(`+${this.carrying}`, this.x, this.y - 30, '#f1c40f'); this.carrying = 0;

                    if (this.isAutoWorker) {
                        // Otomatik √ßalƒ±≈üan i≈ü√ßi: √ñnce eski hedefi kontrol et, yoksa yeni en iyi g√∂revi bul
                        if (this.prevTarget && this.prevTarget.hp > 0) {
                            this.target = this.prevTarget;
                            this.state = (this.target.type === 'farm' && this.target.constructionProgress >= 100) ? 'gather' : 'idle';
                        } else {
                            this.findBestTask();
                        }
                    } else {
                        // Manuel √ßalƒ±≈üan i≈ü√ßi: Sadece eski hedefi kontrol et, yoksa bo≈üta kal
                        this.state = 'idle';
                    }
                }
            }

            returnCargo() {
                const dropoff = entities.find(e => e.team === this.team && e.type === 'towncenter' && e.constructionProgress >= 100);
                if (dropoff) { this.prevTarget = this.target; this.target = dropoff; this.state = 'return'; }
            }

            draw() {
                const screenX = (this.x - camera.x) * zoomLevel; const screenY = (this.y - camera.y) * zoomLevel;
                if (screenX < -100 || screenX > SCREEN_W + 100 || screenY < -100 || screenY > SCREEN_H + 100) return;
                CTX.save(); CTX.translate(screenX, screenY); CTX.scale(zoomLevel, zoomLevel);

                let isSelected = selectedEntities.includes(this);

                // D√º≈üman/Dost Saƒülƒ±k √áubuƒüu
                const isUnit = ['villager', 'special_villager', 'soldier', 'cavalry', 'archer', 'hero', 'pikeman', 'healer', 'herocavalry', 'heavy_infantry', 'siege_engineer', 'crossbowman', 'castle_guard', 'catapult', 'shieldman', 'berserker'].includes(this.type);
                const showHealthBar = this.hp < this.maxHp || isSelected || this.team !== TEAM_PLAYER;

                if (showHealthBar) {
                    const barW = 40;
                    const barY = -this.radius - (isUnit ? 20 : 30);
                    CTX.fillStyle = '#333';
                    CTX.fillRect(-barW / 2, barY, barW, 6);
                    CTX.fillStyle = '#e74c3c';
                    CTX.fillRect(-barW / 2 + 1, barY + 1, barW - 2, 4);
                    CTX.fillStyle = (this.team === TEAM_PLAYER) ? '#2ecc71' : (this.team === TEAM_ENEMY ? '#c0392b' : '#f1c40f');
                    CTX.fillRect(-barW / 2 + 1, barY + 1, (barW - 2) * (this.hp / this.maxHp), 4);
                }

                if (isSelected) {
                    CTX.save(); CTX.scale(1, 0.5); CTX.beginPath(); CTX.strokeStyle = '#2ecc71'; CTX.lineWidth = 3; CTX.arc(0, 0, this.radius + 10, 0, Math.PI * 2); CTX.stroke(); CTX.restore();
                }


                if (this.rallyPoint && selectedEntities.includes(this)) {
                    CTX.save();
                    CTX.translate(this.rallyPoint.x - this.x, this.rallyPoint.y - this.y);
                    CTX.fillStyle = '#e74c3c';
                    CTX.beginPath(); CTX.moveTo(0, 0); CTX.lineTo(15, -10); CTX.lineTo(0, -20); CTX.fill();
                    CTX.strokeStyle = '#fff'; CTX.lineWidth = 2; CTX.beginPath(); CTX.moveTo(0, 0); CTX.lineTo(0, -30); CTX.stroke();
                    CTX.restore();
                }

                if (['villager', 'special_villager', 'soldier', 'archer', 'pikeman', 'healer', 'heavy_infantry', 'siege_engineer', 'crossbowman', 'castle_guard', 'shieldman', 'berserker'].includes(this.type)) {
                    let action = this.carrying > 0 ? this.gatherType : null;
                    drawHuman(CTX, COLORS[this.team], this.type, action);
                }
                else if (this.type === 'cavalry' || this.type === 'herocavalry') { drawHeavyCavalry(CTX, COLORS[this.team], this.type); }
                else if (this.type === 'hero') { drawHero(CTX, COLORS[this.team]); }
                else if (this.type === 'catapult') { drawCatapult(CTX, COLORS[this.team]); }
                else if (this.team === TEAM_NATURE) { drawResource(CTX, this.type); }
                else { drawBuilding(CTX, this.type, COLORS[this.team], this.constructionProgress, this); }
                CTX.restore();
            }
        }

        function checkWallCollision(x, y, me) {
            return entities.find(e => {
                if (e.type !== 'wall') return false; if (e === me) return false; if (e.constructionProgress < 100) return false;
                if (e.team === me.team) return false;
                return Math.sqrt((e.x - x) ** 2 + (e.y - y) ** 2) < (e.radius + me.radius);
            });
        }

        function createBaseWalls(cx, cy, team) {
            const size = 250;
            const step = 40;

            let towerPositions = [
                { x: cx - size, y: cy - size }, { x: cx + size, y: cy - size },
                { x: cx - size, y: cy + size }, { x: cx + size, y: cy + size },
                { x: cx, y: cy - size }, { x: cx, y: cy + size },
                { x: cx - size, y: cy }, { x: cx + size, y: cy }
            ];

            towerPositions.forEach(pos => {
                let t = new Entity(pos.x, pos.y, 'tower', team);
                t.constructionProgress = 100;
                entities.push(t);
            });

            for (let x = cx - size + step; x < cx + size; x += step) {
                if (Math.abs(x - cx) > 10) {
                    let w1 = new Entity(x, cy - size, 'wall', team); w1.constructionProgress = 100; entities.push(w1);
                    let w2 = new Entity(x, cy + size, 'wall', team); w2.constructionProgress = 100; entities.push(w2);
                }
            }
            for (let y = cy - size + step; y < cy + size; y += step) {
                if (Math.abs(y - cy) > 10) {
                    let w3 = new Entity(cx - size, y, 'wall', team); w3.constructionProgress = 100; entities.push(w3);
                    let w4 = new Entity(cx + size, y, 'wall', team); w4.constructionProgress = 100; entities.push(w4);
                }
            }
        }

        function createParticles(x, y, color, count = 5) { for (let i = 0; i < count; i++) { particles.push({ x: x, y: y, vx: (Math.random() - 0.5) * 3, vy: (Math.random() - 0.5) * 3, life: 1.0, color: color }); } }
        function showFloatText(text, x, y, color) { floatTexts.push({ text, x, y, color, life: 1.0 }); }
        function getDist(e1, e2) { return Math.sqrt((e1.x - e2.x) ** 2 + (e1.y - e2.y) ** 2); }

        // Askerler i√ßin tehdit √∂nceliƒüi (Birimler ve Kuleler/Kale)
        function findNearestEnemyThreat(entity) {
            let nearest = null; let minD = Infinity;
            entities.forEach(e => {
                // Sadece hareketli birimler, kuleler, duvarlar ve Town Center tehdit sayƒ±lƒ±r
                const isThreat = ['soldier', 'archer', 'cavalry', 'hero', 'pikeman', 'tower', 'towncenter', 'wall', 'herocavalry', 'heavy_infantry', 'siege_engineer', 'crossbowman', 'castle_guard', 'catapult', 'shieldman', 'berserker'].includes(e.type);
                if (e.team !== entity.team && e.hp > 0 && e.team !== TEAM_NATURE && isThreat) {
                    const d = getDist(entity, e);
                    if (d < minD) {
                        minD = d; nearest = e;
                    }
                }
            });
            return nearest;
        }

        // Genel d√º≈üman bulma (Tower AI i√ßin)
        function findNearestEnemy(entity) {
            let nearest = null; let minD = Infinity; entities.forEach(e => { if (e.team !== entity.team && e.team !== TEAM_NATURE && e.hp > 0) { const d = getDist(entity, e); if (d < minD) { minD = d; nearest = e; } } }); return nearest;
        }

        // Yeni Fonksiyon: D√º≈üman Binalarƒ±nƒ± √∂ncelik sƒ±rasƒ±na g√∂re bulur (TC hari√ß)
        function findHighestPriorityObjective(entity) {
            let bestTarget = null;
            let bestPriority = -1; // Y√ºksek sayƒ± = Y√ºksek √ñncelik
            let minDist = Infinity;

            // Yapƒ± Hedef √ñncelikleri: Askeri √úretim (3) > Savunma/Duvar (2) > Ekonomi (1)
            const priorityMap = {
                'barracks': 3,
                'archery_range': 3,
                'tower': 2,
                'wall': 2,
                'house': 1,
                'farm': 1,
                'conversion_center': 1 // D√∂n√º≈ü√ºm Merkezi
            };

            // Town Center hari√ß, ayakta duran d√º≈üman yapƒ±larƒ±nƒ± kontrol et
            const targetEntities = entities.filter(e => e.team === TEAM_ENEMY && e.hp > 0 && e.type !== 'towncenter');

            for (const e of targetEntities) {
                const priority = priorityMap[e.type] || 0;
                const d = getDist(entity, e);

                // √ñncelik Kontrol√º: Daha y√ºksek √∂ncelikli bir hedef bulursak hemen onu se√ß.
                if (priority > bestPriority) {
                    bestPriority = priority;
                    bestTarget = e;
                    minDist = d;
                }
                // E≈üit √∂ncelikteyse, en yakƒ±n olanƒ± se√ß.
                else if (priority === bestPriority && d < minDist) {
                    bestTarget = e;
                    minDist = d;
                }
            }

            return bestTarget;
        }

        function changeZoom(delta) { zoomLevel += delta; if (zoomLevel < 0.5) zoomLevel = 0.5; if (zoomLevel > 2.0) zoomLevel = 2.0; }

        function commandArmy(action, forceAll = false) {
            let targets = [];

            if (forceAll) {
                // Kale muhafƒ±zlarƒ± global emirlere dahil edilmez
                targets = entities.filter(e => e.team === TEAM_PLAYER && ['soldier', 'cavalry', 'hero', 'archer', 'pikeman', 'healer', 'herocavalry', 'heavy_infantry', 'siege_engineer', 'crossbowman', 'catapult', 'shieldman', 'berserker'].includes(e.type));
            } else {
                targets = selectedEntities.filter(e => ['soldier', 'cavalry', 'hero', 'archer', 'pikeman', 'healer', 'herocavalry', 'heavy_infantry', 'siege_engineer', 'crossbowman', 'castle_guard', 'catapult', 'shieldman', 'berserker'].includes(e.type));
                if (targets.length === 0) {
                    // Eƒüer se√ßim yoksa, yine muhafƒ±zlarƒ± hari√ß tut
                    targets = entities.filter(e => e.team === TEAM_PLAYER && ['soldier', 'cavalry', 'hero', 'archer', 'pikeman', 'healer', 'herocavalry', 'heavy_infantry', 'siege_engineer', 'crossbowman', 'catapult', 'shieldman', 'berserker'].includes(e.type));
                }
            }

            if (targets.length === 0) { notify("Askerin yok lordum!"); return; }

            if (action === 'attack') {
                const enemyTC = entities.find(e => e.team === TEAM_ENEMY && e.type === 'towncenter' && e.hp > 0);

                if (enemyTC) {
                    // armyObjective'i sadece bir hedef olarak i≈üaretliyoruz. 
                    armyObjective = { x: enemyTC.x, y: enemyTC.y, targetEntity: enemyTC };

                    targets.forEach(u => {
                        // Muhafƒ±zlar kendi mantƒ±klarƒ±na sahip olduƒüundan, burada sadece muhafƒ±z olmayanlara komut veriyoruz
                        if (!u.isGuard) {
                            if (u.type === 'healer') {
                                u.state = 'move';
                            } else {
                                u.state = 'move';
                            }
                            u.target = { x: armyObjective.x, y: armyObjective.y };
                            u.isRetreating = false;
                            u.retreatTarget = null; // Geri √ßekilme hedefi temizlendi
                        }
                    });

                    if (forceAll) notify("T√úM ORDU KALE HEDEFLƒ∞ H√úCUM!");
                    else notify("H√úCUM! √ñncelik d√º≈üman savunmalarƒ±nda!");

                } else {
                    notify("D√º≈üman Kalesi yok edildi!");
                    armyObjective = null;
                }
            } else if (action === 'retreat') {
                armyObjective = null;
                const myTC = entities.find(e => e.team === TEAM_PLAYER && e.type === 'towncenter');
                if (myTC) {
                    targets.forEach(u => {
                        // Muhafƒ±zlar kendi postlarƒ±na d√∂necek, diƒüerleri TC'ye
                        if (u.isGuard) {
                            u.state = 'move';
                            u.target = u.guardPost;
                            u.isRetreating = false;
                            u.retreatTarget = null;
                        } else {
                            // Geri √ßekilme emri geldiƒüinde, birimin g√ºncel hedefi ve durumu ne olursa olsun sƒ±fƒ±rlanƒ±r.
                            const tcLocation = { x: myTC.x, y: myTC.y };
                            u.target = tcLocation;
                            u.retreatTarget = tcLocation; // Geri √ßekilme hedefini kaydet
                            u.state = 'move';
                            u.isRetreating = true; // Acil Geri √áekilme Bayraƒüƒ±
                        }
                    });
                    if (forceAll) notify("T√úM ORDU ACƒ∞L GERƒ∞ √áEKƒ∞Lƒ∞YOR!");
                    else notify("Geri √áekilin!");
                }
            }
        }

        // Kaynak D√∂n√º≈ü√ºm√º
        function convertResource(resourceType, amount = 100, output = 50, outputType = 'gold') {
            if (resources[resourceType] >= amount) {
                resources[resourceType] -= amount;
                resources[outputType] += output;
                const outputName = outputType === 'gold' ? 'Altƒ±n' : (outputType === 'wood' ? 'Odun' : 'Et');
                notify(`${amount} ${resourceType.toUpperCase()} d√∂n√º≈üt√ºr√ºld√º. +${output} ${outputName}!`);
                updateUI();
            } else {
                notify(`Yeterli ${resourceType.toUpperCase()} yok! (${amount} gerekli)`);
            }
        }

        function startGatherArmy() {
            buildingMode = 'gather_army';
            notify("Toplanma yeri se√ß (Yere dokun)");
        }

        function executeGatherArmy(x, y) {
            let units = entities.filter(e => e.team === TEAM_PLAYER && ['soldier', 'cavalry', 'hero', 'archer', 'pikeman', 'healer', 'herocavalry', 'heavy_infantry', 'siege_engineer', 'crossbowman', 'catapult', 'shieldman', 'berserker'].includes(e.type));
            if (units.length === 0) { notify("Askerin yok!"); return; }
            units.forEach(u => {
                u.state = 'move';
                u.target = { x: x, y: y };
                u.isRetreating = false;
            });
            createParticles(x, y, '#f1c40f', 10);
            notify("Ordu toplanƒ±yor!");
        }

        function setRallyPointMode() {
            buildingMode = 'rally_point';
            notify("Bayrak dikmek i√ßin yere dokun");
        }

        function startGame() {
            if (!gameStarted) {
                document.getElementById('start-screen').style.display = 'none';
                document.getElementById('ui-layer').style.display = 'block';
                gameStarted = true;
                initGame();
            }
        }

        function resetGame() {
            document.getElementById('restart-overlay').style.display = 'none';
            isGameOver = false;
            projectiles = [];
            particles = [];
            floatTexts = [];
            selectedEntities = [];
            armyObjective = null;

            // Ba≈ülangƒ±√ß kaynaklarƒ±nƒ± sƒ±fƒ±rla (3000)
            resources = { food: 3000, wood: 3000, gold: 3000, pop: 0, maxPop: 20 };

            clearInterval(enemyAiInterval);
            clearInterval(enemyBuildInterval);
            clearInterval(limitInterval);

            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
            }

            initGame();
        }

        function initGame() {
            entities = []; // Reset entities
            for (let i = 0; i < 150; i++) entities.push(new Entity(Math.random() * WORLD_W, Math.random() * WORLD_H, 'tree', TEAM_NATURE));
            for (let i = 0; i < 60; i++) entities.push(new Entity(Math.random() * WORLD_W, Math.random() * WORLD_H, 'gold_mine', TEAM_NATURE));
            for (let i = 0; i < 40; i++) entities.push(new Entity(Math.random() * WORLD_W, Math.random() * WORLD_H, 'bush', TEAM_NATURE));

            const startX = WORLD_W / 2; const startY = WORLD_H / 2;
            entities.push(new Entity(startX, startY, 'towncenter', TEAM_PLAYER));
            createBaseWalls(startX, startY, TEAM_PLAYER);

            // YENƒ∞ Bƒ∞NA: D√∂n√º≈üt√ºrme Merkezi (Conversion Center)
            let convX = startX + 100;
            let convY = startY - 100;
            let cc = new Entity(convX, convY, 'conversion_center', TEAM_PLAYER);
            cc.constructionProgress = 100; // Hazƒ±r ba≈ülasƒ±n
            entities.push(cc);

            // Ba≈ülangƒ±√ß i≈ü√ßilerine otomatik √ßalƒ±≈üma izni ver (ƒ∞lk 5)
            for (let i = 0; i < 5; i++) {
                let angle = (Math.PI * 2 * i) / 5;
                let v = new Entity(startX + Math.cos(angle) * 80, startY + Math.sin(angle) * 80, 'villager', TEAM_PLAYER);
                v.isAutoWorker = true; // Otomatik √ßalƒ±≈üan olarak i≈üaretle
                entities.push(v);
                v.findBestTask(); // Hemen g√∂rev bulmaya ba≈ülasƒ±n
            }

            // YENƒ∞ EKLENEN ASKERLER (5 Adet)
            for (let i = 0; i < 5; i++) {
                let angle = (Math.PI * 2 * i) / 5;
                let sx = startX + Math.cos(angle) * 150;
                let sy = startY + Math.sin(angle) * 150;
                entities.push(new Entity(sx, sy, 'soldier', TEAM_PLAYER));
            }

            // Hero ve Korumalarƒ±nƒ±n Olu≈üturulmasƒ± (S√ºvari olarak g√ºncellendi)
            entities.push(new Entity(startX - 80, startY + 80, 'cavalry', TEAM_PLAYER));
            let hero = new Entity(startX, startY + 120, 'hero', TEAM_PLAYER);
            entities.push(hero);

            // 2 Adet Hero S√ºvari Korumasƒ± olu≈ütur
            for (let i = 0; i < 2; i++) {
                let angle = (Math.PI * 2 * i) / 2; // Sadece 2 y√∂ne yerle≈ütir
                // Kahramana yakƒ±n bir konumda olu≈ütur
                let gx = hero.x + Math.cos(angle) * 50;
                let gy = hero.y + Math.sin(angle) * 50;
                let guard = new Entity(gx, gy, 'herocavalry', TEAM_PLAYER); // S√ºvari koruma tipi
                guard.guarding = hero; // Korumayƒ± Hero'ya baƒüla
                entities.push(guard);
            }

            // YENƒ∞: 10 Kale Muhafƒ±zƒ±
            const tcRadius = 60;
            for (let i = 0; i < 10; i++) {
                let angle = (Math.PI * 2 * i) / 10;
                let gx = startX + Math.cos(angle) * tcRadius;
                let gy = startY + Math.sin(angle) * tcRadius;
                let guard = new Entity(gx, gy, 'castle_guard', TEAM_PLAYER);
                entities.push(guard);
            }


            const ex = 300; const ey = 300;

            // D√º≈üman TC'yi 3x Can ile olu≈ütur
            let enemyTC = new Entity(ex, ey, 'towncenter', TEAM_ENEMY);
            enemyTC.maxHp *= 3; // 3000 -> 9000
            enemyTC.hp = enemyTC.maxHp;
            entities.push(enemyTC);

            // D√º≈üman kalesi etrafƒ±na sur √ßek
            createBaseWalls(ex, ey, TEAM_ENEMY);

            entities.push(new Entity(ex + 50, ey + 50, 'villager', TEAM_ENEMY));
            entities.push(new Entity(ex - 50, ey + 50, 'villager', TEAM_ENEMY));

            entities.push(new Entity(ex + 80, ey, 'tower', TEAM_ENEMY)); entities[entities.length - 1].constructionProgress = 100;
            entities.push(new Entity(ex - 80, ey, 'tower', TEAM_ENEMY)); entities[entities.length - 1].constructionProgress = 100;

            camera.x = startX - SCREEN_W / 2; camera.y = startY - SCREEN_H / 2;
            updateUI(); updatePopulationLimit();

            // AGRESƒ∞F G√úNCELLEME: √úretim hƒ±zlandƒ±rƒ±ldƒ± (2500ms)
            enemyAiInterval = setInterval(enemyAI, 2500);
            // AGRESƒ∞F G√úNCELLEME: ƒ∞n≈üaat hƒ±zƒ± hƒ±zlandƒ±rƒ±ldƒ± (5000ms)
            enemyBuildInterval = setInterval(enemyBuildAI, 5000);
            limitInterval = setInterval(updatePopulationLimit, 1000);

            gameLoop();
        }

        let currentMouseX = 0; let currentMouseY = 0;

        function gameLoop() {
            if (!gameStarted) return;

            // Otomatik ƒ∞n≈üaat Devralma Kontrol√º (Her 0.5 saniyede bir)
            if (gameLoopId % 30 === 0) {
                const incompleteBuildings = entities.filter(e => e.team === TEAM_PLAYER && e.constructionProgress < 100);

                for (const building of incompleteBuildings) {
                    const hasActiveBuilder = entities.some(e =>
                        (e.type === 'villager' || e.type === 'special_villager') &&
                        e.team === TEAM_PLAYER &&
                        e.hp > 0 &&
                        e.target === building &&
                        e.state === 'build'
                    );

                    if (!hasActiveBuilder) {
                        // En yakƒ±n bo≈üta veya otomatik g√∂revde olan i≈ü√ßiyi bul
                        let nearestVillager = null;
                        let minDist = Infinity;

                        entities.filter(e =>
                            (e.type === 'villager' || e.type === 'special_villager') &&
                            e.team === TEAM_PLAYER &&
                            (e.state === 'idle' || e.isAutoWorker) &&
                            e.hp > 0
                        ).forEach(v => {
                            const dist = getDist(v, building);
                            if (dist < minDist) {
                                minDist = dist;
                                nearestVillager = v;
                            }
                        });

                        if (nearestVillager && minDist < 800) { // Maksimum 800 birim menzil
                            nearestVillager.target = building;
                            nearestVillager.state = 'build';
                            nearestVillager.isAutoWorker = true; // ƒ∞n≈üaata ba≈ülayan otomatikle≈üir
                        }
                    }
                }
            }


            CTX.clearRect(0, 0, CANVAS.width, CANVAS.height);
            CTX.fillStyle = '#27ae60'; CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);
            CTX.strokeStyle = 'rgba(0,0,0,0.05)'; CTX.lineWidth = 1;
            const gridSize = TILE_SIZE * zoomLevel;
            const offsetX = -(camera.x * zoomLevel) % gridSize; const offsetY = -(camera.y * zoomLevel) % gridSize;
            CTX.beginPath();
            for (let x = offsetX; x < SCREEN_W; x += gridSize) { CTX.moveTo(x, 0); CTX.lineTo(x, SCREEN_H); }
            for (let y = offsetY; y < SCREEN_H; y += gridSize) { CTX.moveTo(0, y); CTX.lineTo(SCREEN_W, y); }
            CTX.stroke();

            if (clickMarker && clickMarker.life > 0) {
                const cx = (clickMarker.x - camera.x) * zoomLevel; const cy = (clickMarker.y - camera.y) * zoomLevel;
                CTX.strokeStyle = `rgba(255, 255, 255, ${clickMarker.life})`; CTX.lineWidth = 2;
                CTX.beginPath(); CTX.moveTo(cx - 5, cy - 5); CTX.lineTo(cx + 5, cy + 5); CTX.moveTo(cx + 5, cy - 5); CTX.lineTo(cx - 5, cy + 5); CTX.stroke();
                clickMarker.life -= 0.05;
            }

            if (!isGameOver) {
                const enemyTC = entities.find(e => e.team === TEAM_ENEMY && e.type === 'towncenter');
                const playerTC = entities.find(e => e.team === TEAM_PLAYER && e.type === 'towncenter');

                if (!enemyTC || !playerTC) {
                    isGameOver = true;
                    document.getElementById('restart-overlay').style.display = 'flex';
                    let title = document.getElementById('game-over-title');
                    let msg = document.getElementById('game-over-msg');
                    if (!enemyTC) {
                        title.innerText = "ZAFER SENƒ∞N!"; title.style.color = "#f1c40f"; msg.innerText = "D√º≈üman imparatorluƒüu yok edildi.";
                        for (let i = 0; i < 100; i++) createParticles(camera.x + Math.random() * SCREEN_W, camera.y + Math.random() * SCREEN_H, ['#f1c40f', '#e74c3c', '#3498db'][Math.floor(Math.random() * 3)], 1);
                    } else {
                        title.innerText = "YENƒ∞LDƒ∞N!"; title.style.color = "#e74c3c"; msg.innerText = "Halkƒ±n katledildi...";
                    }
                }
            }

            entities.sort((a, b) => a.y - b.y);
            entities = entities.filter(e => e.update(1));
            entities.forEach(e => e.draw());

            projectiles = projectiles.filter(p => p.update());
            projectiles.forEach(p => {
                const sx = (p.x - camera.x) * zoomLevel; const sy = (p.y - camera.y) * zoomLevel;
                CTX.save(); CTX.translate(sx, sy); CTX.scale(zoomLevel, zoomLevel); CTX.rotate(p.angle);
                CTX.fillStyle = 'white'; CTX.fillRect(-5, -1, 10, 2); CTX.fillStyle = '#555'; CTX.fillRect(5, -2, 3, 4); CTX.restore();
            });

            particles.forEach(p => {
                p.x += p.vx; p.y += p.vy; p.life -= 0.03;
                const sx = (p.x - camera.x) * zoomLevel; const sy = (p.y - camera.y) * zoomLevel;
                CTX.globalAlpha = p.life; CTX.fillStyle = p.color; CTX.fillRect(sx, sy, 4 * zoomLevel, 4 * zoomLevel);
                CTX.globalAlpha = 1;
            });
            particles = particles.filter(p => p.life > 0); // D√ºzg√ºn temizleme

            floatTexts.forEach(ft => {
                ft.y -= 0.5; ft.life -= 0.02; CTX.globalAlpha = ft.life;
                CTX.fillStyle = ft.color; CTX.font = `bold ${14 * zoomLevel}px Arial`; CTX.fillText(ft.text, (ft.x - camera.x) * zoomLevel, (ft.y - camera.y) * zoomLevel); CTX.globalAlpha = 1;
            });
            floatTexts = floatTexts.filter(ft => ft.life > 0);

            if (buildingMode) {
                if (buildingMode === 'wall' && wallStartPoint) {
                    const startX = (wallStartPoint.x - camera.x) * zoomLevel; const startY = (wallStartPoint.y - camera.y) * zoomLevel;
                    const endX = currentMouseX; const endY = currentMouseY;
                    CTX.save(); CTX.strokeStyle = 'rgba(255, 255, 255, 0.5)'; CTX.lineWidth = 40 * zoomLevel; CTX.lineCap = 'round';
                    CTX.beginPath(); CTX.moveTo(startX, startY); CTX.lineTo(endX, endY); CTX.stroke();
                    const dist = Math.sqrt((wallStartPoint.x - (endX / zoomLevel + camera.x)) ** 2 + (wallStartPoint.y - (endY / zoomLevel + camera.y)) ** 2);
                    const count = Math.max(1, Math.ceil(dist / 30)); const totalCost = count * 10;
                    CTX.fillStyle = 'white'; CTX.font = 'bold 20px Arial'; CTX.textAlign = 'center'; CTX.fillText(`${count} Duvar - Maliyet: ${totalCost} Odun`, (startX + endX) / 2, (startY + endY) / 2 - 30); CTX.restore();
                } else if (buildingMode === 'rally_point') {
                    CTX.fillStyle = '#f1c40f'; CTX.font = 'bold 18px Arial'; CTX.textAlign = 'center';
                    CTX.fillText("BAYRAK KONUMU SE√á", SCREEN_W / 2, 100);
                } else if (buildingMode === 'gather_army') {
                    CTX.fillStyle = '#f1c40f'; CTX.font = 'bold 18px Arial'; CTX.textAlign = 'center';
                    CTX.fillText("ORDU TOPLANMA ALANI SE√á", SCREEN_W / 2, 100);
                } else {
                    CTX.fillStyle = '#f1c40f'; CTX.font = 'bold 18px Arial'; CTX.textAlign = 'center'; CTX.shadowColor = 'black'; CTX.shadowBlur = 4;
                    let msg = "Konumu se√ßmek i√ßin Yere Dokun"; if (buildingMode === 'wall') msg = "Duvar BA≈ûLANGI√á noktasƒ±na dokun";
                    CTX.fillText(msg, SCREEN_W / 2, SCREEN_H / 2 - 80); CTX.shadowBlur = 0;
                }
            }
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        let isDragging = false; let startX, startY; let lastCamX, lastCamY;
        CANVAS.addEventListener('pointerdown', (e) => {
            isDragging = true; startX = e.clientX; startY = e.clientY; lastCamX = camera.x; lastCamY = camera.y; currentMouseX = e.clientX; currentMouseY = e.clientY;
        });
        CANVAS.addEventListener('pointermove', (e) => {
            currentMouseX = e.clientX; currentMouseY = e.clientY;
            if (isDragging) {
                camera.x = lastCamX - (e.clientX - startX) / zoomLevel; camera.y = lastCamY - (e.clientY - startY) / zoomLevel;
                camera.x = Math.max(0, Math.min(camera.x, WORLD_W - SCREEN_W / zoomLevel)); camera.y = Math.max(0, Math.min(camera.y, WORLD_H - SCREEN_H / zoomLevel));
            }
        });
        CANVAS.addEventListener('pointerup', (e) => { isDragging = false; if (Math.sqrt((e.clientX - startX) ** 2 + (e.clientY - startY) ** 2) < 10) handleTap(e.clientX, e.clientY); });

        function handleTap(screenX, screenY) {
            const worldX = screenX / zoomLevel + camera.x; const worldY = screenY / zoomLevel + camera.y;
            if (isGameOver) return;
            if (buildingMode) {
                if (buildingMode === 'wall') {
                    if (!wallStartPoint) { wallStartPoint = { x: worldX, y: worldY }; notify("≈ûimdi Bƒ∞Tƒ∞≈û noktasƒ±na dokun"); }
                    else { placeWallLine(wallStartPoint.x, wallStartPoint.y, worldX, worldY); wallStartPoint = null; buildingMode = null; updateUI(); }
                } else if (buildingMode === 'rally_point') {
                    if (selectedEntities.length > 0) {
                        selectedEntities[0].rallyPoint = { x: worldX, y: worldY };
                        notify("Bayrak dikildi!");
                    }
                    buildingMode = null;
                    updateUI();
                } else if (buildingMode === 'gather_army') {
                    executeGatherArmy(worldX, worldY);
                    buildingMode = null;
                } else {
                    placeBuilding(worldX, worldY, buildingMode); buildingMode = null; updateUI();
                }
                return;
            }
            const candidates = entities.filter(e => Math.abs(e.x - worldX) < e.radius + 15 && Math.abs(e.y - worldY) < e.radius + 15);
            candidates.sort((a, b) => {
                if (selectedEntities.length > 0 && selectedEntities[0].team === TEAM_PLAYER) {
                    const aIsEnemy = a.team !== TEAM_PLAYER; const bIsEnemy = b.team !== TEAM_PLAYER;
                    if (aIsEnemy && !bIsEnemy) return -1; if (bIsEnemy && !aIsEnemy) return 1;
                }
                const aIsMobile = ['villager', 'special_villager', 'soldier', 'cavalry', 'hero', 'archer', 'pikeman', 'healer', 'herocavalry', 'heavy_infantry', 'siege_engineer', 'crossbowman', 'castle_guard', 'catapult', 'shieldman', 'berserker'].includes(a.type);
                const bIsMobile = ['villager', 'special_villager', 'soldier', 'cavalry', 'hero', 'archer', 'pikeman', 'healer', 'herocavalry', 'heavy_infantry', 'siege_engineer', 'crossbowman', 'castle_guard', 'catapult', 'shieldman', 'berserker'].includes(b.type);
                if (aIsMobile && !bIsMobile) return -1; if (!aIsMobile && bIsMobile) return 1;
                return Math.sqrt((a.x - worldX) ** 2 + (a.y - worldY) ** 2) - Math.sqrt((b.x - worldX) ** 2 + (b.y - worldY) ** 2);
            });
            const clicked = candidates[0];
            if (clicked) {
                if (clicked.team === TEAM_PLAYER) {
                    const currentTime = new Date().getTime();
                    // Yerel Hƒ±zlƒ± Se√ßim
                    if (lastClickedType === clicked.type && currentTime - lastClickTime < 500) {
                        clickCount++;
                    } else {
                        clickCount = 1;
                        lastClickedType = clicked.type;
                    }
                    lastClickTime = currentTime;

                    if (clickCount >= 2) { // Double click (2 veya daha fazla)
                        const nearbyUnits = entities.filter(e =>
                            e.team === TEAM_PLAYER &&
                            e.type === clicked.type &&
                            getDist(e, clicked) < 250 // 250 birim yarƒ±√ßap
                        );
                        selectedEntities = nearbyUnits;
                        notify(`Yakƒ±n ${clicked.type.toUpperCase()} birlikleri se√ßildi! (${nearbyUnits.length})`);
                        clickCount = 0;
                    } else {
                        selectedEntities = [clicked];
                    }
                    updateUI();
                } else if (selectedEntities.length > 0) { setCommand(clicked); createParticles(clicked.x, clicked.y, '#c0392b', 3); clickMarker = { x: worldX, y: worldY, life: 1 }; }
            } else {
                if (selectedEntities.length > 0 && selectedEntities[0].team === TEAM_PLAYER) {
                    selectedEntities.forEach(u => {
                        u.state = 'move';
                        u.target = { x: worldX, y: worldY };
                        u.gatherType = null;
                        u.isRetreating = false;
                    });
                    createParticles(worldX, worldY, '#2ecc71', 5); clickMarker = { x: worldX, y: worldY, life: 1 };
                } else { selectedEntities = []; updateUI(); }
            }
        }

        function setCommand(target) {
            selectedEntities.forEach(selectedEntity => {
                selectedEntity.isRetreating = false;
                selectedEntity.retreatTarget = null; // Geri √ßekilme hedefi temizlendi
                // Hedef TC ise, genel saldƒ±rƒ± amacƒ±nƒ± temizle. Bireysel komutlar √∂nceliklidir.
                if (armyObjective && armyObjective.targetEntity === target) {
                    armyObjective = null;
                }

                if (selectedEntity.type === 'villager' || selectedEntity.type === 'special_villager') {

                    // ƒ∞≈ü√ßi ilk kez bir g√∂rev aldƒ±ƒüƒ±nda otomatik g√∂revli olur.
                    const isGatherOrBuild = ['tree', 'bush', 'gold_mine', 'farm'].includes(target.type) ||
                        (target.team === TEAM_PLAYER && target.constructionProgress < 100);

                    if (isGatherOrBuild) {
                        selectedEntity.isAutoWorker = true;
                    }

                    // Kaynak toplama
                    if (['tree', 'bush', 'gold_mine'].includes(target.type)) {
                        selectedEntity.target = target; selectedEntity.state = 'gather';
                        if (target.type === 'tree') selectedEntity.gatherType = 'wood';
                        else if (target.type === 'gold_mine') selectedEntity.gatherType = 'gold'; else selectedEntity.gatherType = 'food';
                    }
                    // Yapƒ± in≈üa/toplama atamasƒ±
                    else if (target.team === TEAM_PLAYER && target.type !== 'towncenter') {
                        if (target.constructionProgress < 100) {
                            // ƒ∞n≈üaat halindeki yapƒ±ya: ƒ∞n≈üa et
                            selectedEntity.state = 'build';
                            selectedEntity.target = target;
                        } else if (target.type === 'farm' && target.constructionProgress >= 100) {
                            // Tamamlanmƒ±≈ü tarlaya: Topla
                            selectedEntity.state = 'gather';
                            selectedEntity.target = target;
                            selectedEntity.gatherType = 'farm';
                        }
                    }
                    // D√º≈üman birimi
                    else if (target.team === TEAM_ENEMY) {
                        selectedEntity.state = selectedEntity.type === 'healer' ? 'move' : 'attack';
                        selectedEntity.target = target;
                    }
                    // Dost merkeze y√ºr√ºme (veya kaynak bƒ±rakma)
                    else if (target.team === TEAM_PLAYER && ['towncenter', 'house'].includes(target.type)) { selectedEntity.state = 'move'; selectedEntity.target = { x: target.x, y: target.y }; }

                } else if (['soldier', 'cavalry', 'hero', 'archer', 'pikeman', 'healer', 'herocavalry', 'heavy_infantry', 'siege_engineer', 'crossbowman', 'castle_guard', 'catapult', 'shieldman', 'berserker'].includes(selectedEntity.type)) {

                    if (selectedEntity.isGuard) {
                        // Muhafƒ±zlar i√ßin sadece hareket komutu verilebilir, hedefi takip etmezler, hemen postlarƒ±na d√∂nerler
                        selectedEntity.state = 'move'; selectedEntity.target = { x: target.x, y: target.y };
                        if (target.team === TEAM_ENEMY) {
                            notify("Muhafƒ±zlar emirleri dinlemez, sadece postlarƒ±nƒ± korur!");
                        }
                        return;
                    }

                    if (target.team === TEAM_ENEMY) {

                        // BURADAKƒ∞ D√úZELTME: Eƒüer hedef d√º≈üman TC ise, doƒürudan saldƒ±rma emri yerine Toplu Saldƒ±rƒ± mantƒ±ƒüƒ±na ge√ß
                        if (target.type === 'towncenter') {
                            const enemyTC = entities.find(e => e.team === TEAM_ENEMY && e.type === 'towncenter' && e.hp > 0);
                            if (enemyTC) {
                                // armyObjective'i belirle, b√∂ylece birimin update d√∂ng√ºs√º √∂ncelik sistemini kullanƒ±r.
                                armyObjective = { x: enemyTC.x, y: enemyTC.y, targetEntity: enemyTC };

                                // Birime genel hedefe doƒüru hareket emri ver
                                selectedEntity.state = 'move';
                                selectedEntity.target = { x: enemyTC.x, y: enemyTC.y };
                                notify("Town Center hedeflendi. √ñncelik diƒüer d√º≈üman yapƒ±larda!");
                            }
                        } else {
                            // Diƒüer d√º≈üman birim veya yapƒ±larƒ±na doƒürudan saldƒ±rƒ± emri
                            selectedEntity.state = selectedEntity.type === 'healer' ? 'move' : 'attack';
                            selectedEntity.target = target;
                        }
                    }
                    else { selectedEntity.state = 'move'; selectedEntity.target = { x: target.x, y: target.y }; }
                }
            });
        }

        function placeBuilding(x, y, type) {
            let cost = getCost(type);
            if (resources.wood >= cost.wood && resources.gold >= cost.gold) {
                resources.wood -= cost.wood; resources.gold -= cost.gold; updateUI();
                let b = new Entity(x, y, type, TEAM_PLAYER); b.constructionProgress = 0; entities.push(b);
                if (selectedEntities.length > 0 && (selectedEntities[0].type === 'villager' || selectedEntities[0].type === 'special_villager')) { selectedEntities.forEach(v => { v.state = 'build'; v.target = b; v.isAutoWorker = true; }); }
            } else {
                notify("Yetersiz Kaynak!");
            }
        }

        function placeWallLine(x1, y1, x2, y2) {
            const dx = x2 - x1; const dy = y2 - y1; const dist = Math.sqrt(dx * dx + dy * dy);
            const count = Math.max(1, Math.ceil(dist / 30)); const totalCost = count * 10;
            if (resources.wood < totalCost) {
                notify(`Yetersiz Odun! (${totalCost} gerekli)`);
                return;
            }
            resources.wood -= totalCost; updateUI();
            let firstWall = null;
            for (let i = 0; i <= count; i++) {
                const ratio = i / count;
                let b = new Entity(x1 + dx * ratio, y1 + dy * ratio, 'wall', TEAM_PLAYER); b.constructionProgress = 0; entities.push(b); if (i === 0) firstWall = b;
            }
            if (selectedEntities.length > 0 && (selectedEntities[0].type === 'villager' || selectedEntities[0].type === 'special_villager') && firstWall) { selectedEntities.forEach(v => { v.state = 'build'; v.target = firstWall; v.isAutoWorker = true; }); notify("Sur in≈üaatƒ± ba≈üladƒ±!"); }
        }

        function destroySelected() {
            if (selectedEntities.length === 0) return;
            selectedEntities.forEach(e => {
                if (['house', 'farm', 'barracks', 'archery_range', 'wall', 'gate', 'towncenter', 'tower', 'conversion_center'].includes(e.type)) {
                    let cost = getCost(e.type); let refunded = "";
                    if (cost.wood) { let r = Math.floor(cost.wood * 0.75); resources.wood += r; refunded += `+${r} Odun `; }
                    if (cost.gold) { let r = Math.floor(cost.gold * 0.75); resources.gold += r; refunded += `+${r} Altƒ±n `; }
                    if (cost.food) { let r = Math.floor(cost.food * 0.75); resources.food += r; refunded += `+${r} Et `; }
                    showFloatText("ƒ∞ade: " + refunded, e.x, e.y - 20, '#2ecc71');
                }
                createParticles(e.x, e.y, '#7f8c8d', 10);
                e.hp = 0;
            });
            selectedEntities = []; notify("ƒ∞mha Edildi!"); updateUI(); updatePopulationLimit();
        }

        function updatePopulationLimit() {
            let houses = entities.filter(e => e.team === TEAM_PLAYER && e.type === 'house' && e.constructionProgress >= 100).length;
            let tcs = entities.filter(e => e.team === TEAM_PLAYER && e.type === 'towncenter' && e.constructionProgress >= 100).length;
            resources.maxPop = 20 + (houses * 8) + (tcs * 20);
            resources.pop = entities.filter(e => e.team === TEAM_PLAYER && ['villager', 'special_villager', 'soldier', 'cavalry', 'hero', 'archer', 'pikeman', 'healer', 'herocavalry', 'heavy_infantry', 'siege_engineer', 'crossbowman', 'castle_guard', 'catapult', 'shieldman', 'berserker'].includes(e.type)).length;
            document.getElementById('res-food').innerText = Math.floor(resources.food); document.getElementById('res-wood').innerText = Math.floor(resources.wood);
            document.getElementById('res-gold').innerText = Math.floor(resources.gold); document.getElementById('res-pop').innerText = resources.pop + "/" + resources.maxPop;
        }

        function updateUI() {
            const panel = document.getElementById('bottom-panel');
            panel.innerHTML = ''; const info = document.getElementById('selection-info');

            if (selectedEntities.length === 0) {
                info.style.display = 'none';
                addButton(panel, 'TOPLU SALDIRI', '‚öîÔ∏è', {}, () => commandArmy('attack', true), 'attack-btn');
                addButton(panel, 'GERƒ∞ √áEKƒ∞L', 'üõ°Ô∏è', {}, () => commandArmy('retreat', true), 'retreat-btn');
                addButton(panel, 'ORDUYU TOPLA', 'üö©', {}, () => startGatherArmy(), 'gather-btn');
                return;
            }

            info.style.display = 'block';
            let mainSelected = selectedEntities[0];
            let name = mainSelected.type.toUpperCase();
            if (mainSelected.type === 'hero') name = "üëë KRAL LEONIDAS";
            if (mainSelected.type === 'cavalry') name = "S√úVARƒ∞";
            if (mainSelected.type === 'pikeman') name = "MIZRAK√áI";
            if (mainSelected.type === 'healer') name = "≈ûƒ∞FACI";
            if (mainSelected.type === 'herocavalry') name = "Lƒ∞DER S√úVARƒ∞ MUHAFIZI";
            if (mainSelected.type === 'conversion_center') name = "D√ñN√ú≈ûT√úRME MERKEZƒ∞";
            if (mainSelected.type === 'heavy_infantry') name = "AƒûIR Pƒ∞YADE"; // Yeni Birim
            if (mainSelected.type === 'siege_engineer') name = "KU≈ûATMA M√úHENDƒ∞Sƒ∞"; // Yeni Birim
            if (mainSelected.type === 'crossbowman') name = "ARBALET√áƒ∞"; // Yeni Birim
            if (mainSelected.type === 'castle_guard') name = "KALE MUHAFIZI"; // Yeni Birim
            if (mainSelected.type === 'catapult') name = "ü™® MANCINIK"; // Yeni Birim
            if (mainSelected.type === 'shieldman') name = "KALKAN SAVA≈û√áISI"; // Yeni Birim
            if (mainSelected.type === 'berserker') name = "ü™ì BERSERKER"; // Yeni Birim
            if (mainSelected.type === 'special_villager') name = "SE√áƒ∞LMƒ∞≈û ƒ∞≈û√áƒ∞";
            if (selectedEntities.length > 1) name += ` (${selectedEntities.length})`;
            info.innerText = `${name} | HP: ${Math.floor(mainSelected.hp)}/${mainSelected.maxHp}`;
            if (mainSelected.team !== TEAM_PLAYER) { panel.innerHTML = '<div style="color:#e74c3c; font-weight:bold;">D√ú≈ûMAN</div>'; return; }

            const isBuilding = ['house', 'farm', 'barracks', 'archery_range', 'wall', 'gate', 'towncenter', 'tower', 'conversion_center'].includes(mainSelected.type);
            const isUnit = ['villager', 'special_villager', 'soldier', 'cavalry', 'archer', 'hero', 'pikeman', 'healer', 'herocavalry', 'heavy_infantry', 'siege_engineer', 'crossbowman', 'castle_guard', 'catapult', 'shieldman', 'berserker'].includes(mainSelected.type);
            const isProducer = ['towncenter', 'barracks', 'archery_range'].includes(mainSelected.type) && mainSelected.constructionProgress >= 100;

            if (mainSelected.type === 'towncenter' && mainSelected.constructionProgress >= 100) {
                addButton(panel, 'K√∂yl√º', 'üë§', { food: 50 }, () => trainUnit('villager'));
                addButton(panel, 'SE√áƒ∞LMƒ∞≈û', 'üîÆ', { food: 100, gold: 50 }, () => trainUnit('special_villager'), 'special-btn');
                addButton(panel, 'Muhafƒ±z', 'üõ°Ô∏è', { food: 120, gold: 80 }, () => trainUnit('castle_guard'), 'guard-btn'); // Muhafƒ±z √ºretimi
            }
            else if (mainSelected.type === 'villager' || mainSelected.type === 'special_villager') {
                addButton(panel, 'Ev', 'üè†', { wood: 30 }, () => startBuild('house')); addButton(panel, 'Tarla', 'üåæ', { wood: 60 }, () => startBuild('farm'));
                addButton(panel, 'Kƒ±≈üla', '‚öîÔ∏è', { wood: 100 }, () => startBuild('barracks')); addButton(panel, 'Poligon', 'üéØ', { wood: 120 }, () => startBuild('archery_range'));
                addButton(panel, 'Kule', 'üóº', { wood: 80, gold: 20 }, () => startBuild('tower'));
            } else if (mainSelected.type === 'barracks' && mainSelected.constructionProgress >= 100) {
                addButton(panel, 'Asker', 'üõ°Ô∏è', { food: 60, gold: 20 }, () => trainUnit('soldier'));
                addButton(panel, 'Mƒ±zrak√ßƒ±', 'üî±', { food: 80, wood: 40 }, () => trainUnit('pikeman'));

                // YENƒ∞ Bƒ∞Rƒ∞MLER (Kƒ±≈üla)
                addButton(panel, 'Aƒüƒ±r Piyade', 'ü™ñ', { food: 80, wood: 30 }, () => trainUnit('heavy_infantry'), 'melee-btn');
                addButton(panel, 'Kalkan Sava≈ü√ßƒ±sƒ±', 'ü™®', { food: 90, wood: 60 }, () => trainUnit('shieldman'), 'melee-btn');
                addButton(panel, 'Berserker', 'ü™ì', { food: 100, gold: 30 }, () => trainUnit('berserker'), 'attack-btn');
                addButton(panel, 'Ku≈üatma M√ºhendisi', 'üß±', { food: 50, wood: 100 }, () => trainUnit('siege_engineer'), 'siege-btn');
                addButton(panel, 'Mancƒ±nƒ±k', 'ü™®', { wood: 200, gold: 100 }, () => trainUnit('catapult'), 'siege-btn');

                addButton(panel, 'Atlƒ±', 'üêé', { food: 120, gold: 60 }, () => trainUnit('cavalry'));
                addButton(panel, '≈ûifacƒ±', '‚öïÔ∏è', { food: 100, gold: 50 }, () => trainUnit('healer'), 'special-btn');
            } else if (mainSelected.type === 'archery_range' && mainSelected.constructionProgress >= 100) {
                addButton(panel, 'Ok√ßu', 'üèπ', { food: 40, wood: 40 }, () => trainUnit('archer'));

                // YENƒ∞ Bƒ∞Rƒ∞M (Poligon)
                addButton(panel, 'Arbalet√ßi', 'üéØ', { food: 70, gold: 40 }, () => trainUnit('crossbowman'), 'ranged-btn');
            }
            // YENƒ∞ Bƒ∞NA: D√∂n√º≈üt√ºrme Merkezi UI - Oran 100:50 olarak g√ºncellendi

            else if (mainSelected.type === 'conversion_center' && mainSelected.constructionProgress >= 100) {
                addButton(panel, 'ET -> ALTIN', 'ü•©', { food: 100 }, () => convertResource('food', 100, 50), 'special-btn', '+50 Altƒ±n');
                addButton(panel, 'ODUN -> ALTIN', 'ü™µ', { wood: 100 }, () => convertResource('wood', 100, 50), 'special-btn', '+50 Altƒ±n');
                addButton(panel, 'ET -> ODUN', 'ü•©', { food: 100 }, () => convertResource('food', 100, 50, 'wood'), 'special-btn', '+50 Odun');
            }


            else if (mainSelected.type === 'hero' || mainSelected.type === 'herocavalry' || ['heavy_infantry', 'siege_engineer', 'crossbowman', 'castle_guard', 'catapult', 'shieldman', 'berserker'].includes(mainSelected.type)) {
                // Muhafƒ±zlar i√ßin sadece terhis butonu olacak
                if (mainSelected.isGuard) {
                    // Sadece terhis
                } else {
                    // Liderler ve diƒüer askerler i√ßin
                    addButton(panel, 'Lƒ∞DER SALDIRI', '‚öîÔ∏è', {}, () => commandArmy('attack', true), 'attack-btn');
                    addButton(panel, 'Lƒ∞DER √áEKƒ∞L', 'üõ°Ô∏è', {}, () => commandArmy('retreat', true), 'retreat-btn');
                    addButton(panel, 'SALDIR', '‚öîÔ∏è', {}, () => commandArmy('attack'), 'attack-btn');
                }
            }
            else if (['soldier', 'cavalry', 'archer', 'pikeman', 'healer'].includes(mainSelected.type)) {
                addButton(panel, 'SALDIR', '‚öîÔ∏è', {}, () => commandArmy('attack'), 'attack-btn'); addButton(panel, '√áEKƒ∞L', 'üõ°Ô∏è', {}, () => commandArmy('retreat'), 'retreat-btn');
            }

            if (isProducer) {
                addButton(panel, 'BAYRAK', 'üè≥Ô∏è', {}, () => setRallyPointMode(), 'rally-btn');
            }

            if (isBuilding || isUnit) {
                let label = isUnit ? 'TERHƒ∞S' : 'YIK';
                let icon = 'üíÄ';
                addButton(panel, label, icon, {}, () => destroySelected(), 'destroy-btn');
            }
        }

        function addButton(parent, name, icon, cost, callback, extraClass = '', outputText = '') {
            let btn = document.createElement('div'); btn.className = `action-btn ${extraClass}`;
            let costText = "";
            if (cost.food) costText += `ü•©${cost.food} `;
            if (cost.wood) costText += `ü™µ${cost.wood} `;
            if (cost.gold) costText += `ü™ô${cost.gold} `;

            // Maliyet ve ad/ikon birle≈üir, √ßƒ±ktƒ± varsa ayrƒ± bir satƒ±rda g√∂sterilir
            const costHtml = costText ? `<div class="cost">${costText}</div>` : '';
            const outputHtml = outputText ? `<div class="cost" style="color:#2ecc71; font-size:10px;">${outputText}</div>` : '';

            btn.innerHTML = `<span>${icon}</span>${name}${costHtml}${outputHtml}`;
            btn.onclick = (e) => { e.stopPropagation(); callback(); }; parent.appendChild(btn);
        }

        function getCost(type) {
            if (type === 'house') return { wood: 30, gold: 0 }; if (type === 'farm') return { wood: 60, gold: 0 };
            if (type === 'barracks') return { wood: 100, gold: 0 }; if (type === 'archery_range') return { wood: 120, gold: 0 };
            if (type === 'wall') return { wood: 10, gold: 0 }; if (type === 'tower') return { wood: 80, gold: 20 };
            if (type === 'conversion_center') return { wood: 150, gold: 50 };
            if (type === 'villager') return { food: 50 };
            if (type === 'special_villager') return { food: 100, gold: 50 };
            if (type === 'soldier') return { food: 60, gold: 20 };
            if (type === 'pikeman') return { food: 80, wood: 40 };
            if (type === 'healer') return { food: 100, gold: 50 };
            if (type === 'archer') return { food: 40, wood: 40 }; if (type === 'cavalry') return { food: 120, gold: 60 };

            // YENƒ∞ ASKER MALƒ∞YETLERƒ∞
            if (type === 'heavy_infantry') return { food: 80, wood: 30 }; // Aƒüƒ±r Piyade
            if (type === 'siege_engineer') return { food: 50, wood: 100 }; // Ku≈üatma M√ºhendisi
            if (type === 'crossbowman') return { food: 70, gold: 40 }; // Arbalet√ßi
            if (type === 'castle_guard') return { food: 120, gold: 80 }; // Kale Muhafƒ±zƒ±
            if (type === 'catapult') return { wood: 200, gold: 100 }; // Mancƒ±nƒ±k
            if (type === 'shieldman') return { food: 90, wood: 60 }; // Kalkan Sava≈ü√ßƒ±sƒ±
            if (type === 'berserker') return { food: 100, gold: 30 }; // Berserker

            return {};
        }

        function startBuild(type) { buildingMode = type; if (type === 'wall') { wallStartPoint = null; notify("Sur BA≈ûLANGI√á noktasƒ±na dokun"); } else { notify("ƒ∞n≈üa etmek i√ßin yere dokun"); } }

        function trainUnit(type) {
            let cost = getCost(type); if (resources.pop >= resources.maxPop) { notify("N√ºfus Limiti Dolu!"); return; }
            if ((cost.food && resources.food < cost.food) || (cost.wood && resources.wood < cost.wood) || (cost.gold && resources.gold < cost.gold)) {
                notify("Kaynak Yetersiz!");
                return;
            }
            if (cost.food) resources.food -= cost.food; if (cost.wood) resources.wood -= cost.wood; if (cost.gold) resources.gold -= cost.gold;

            let producer = selectedEntities[0];
            let spawnX = producer.x;
            let spawnY = producer.y + 50;

            let u = new Entity(spawnX, spawnY, type, TEAM_PLAYER);

            // √úretilen i≈ü√ßiler otomatik g√∂revli deƒüildir, komut alana kadar beklerler
            u.isAutoWorker = false;

            // Kale muhafƒ±zlarƒ± i√ßin √∂zel post ayarƒ±
            if (u.isGuard) {
                u.guardPost = { x: spawnX, y: spawnY };
            }

            if (producer.rallyPoint) {
                u.state = 'move';
                u.target = { x: producer.rallyPoint.x, y: producer.rallyPoint.y };
            }

            entities.push(u); notify(type + " √ºretiliyor..."); updateUI();
        }

        function notify(msg) {
            const n = document.getElementById('notifications'); const el = document.createElement('div'); el.className = 'toast'; el.innerText = msg; n.appendChild(el);
            setTimeout(() => el.style.opacity = 1, 10); setTimeout(() => { el.style.opacity = 0; setTimeout(() => el.remove(), 500); }, 2000);
        }

        function enemyAI() {
            if (isGameOver) return;
            const enemyTC = entities.find(e => e.team === TEAM_ENEMY && e.type === 'towncenter'); if (!enemyTC) return;

            // AGRESƒ∞F G√úNCELLEME: √áe≈üitli ve daha g√º√ßl√º birim √ºretimi
            let unitType = 'soldier';
            const rnd = Math.random();

            if (rnd < 0.05) { // %5 Cavalry
                unitType = 'cavalry';
            } else if (rnd < 0.15) { // %10 Pikeman
                unitType = 'pikeman';
            } else if (rnd < 0.25) { // %10 Heavy Infantry
                unitType = 'heavy_infantry';
            } else if (rnd < 0.40) { // %15 Archer
                unitType = 'archer';
            } else { // %60 Soldier
                unitType = 'soldier';
            }

            // √úretim
            entities.push(new Entity(enemyTC.x + (Math.random() - 0.5) * 50, enemyTC.y + 40 + (Math.random() - 0.5) * 50, unitType, TEAM_ENEMY));


            const soldiers = entities.filter(e => e.team === TEAM_ENEMY && ['soldier', 'archer', 'pikeman', 'cavalry', 'hero', 'heavy_infantry', 'crossbowman'].includes(e.type));
            // AGRESƒ∞F G√úNCELLEME: Saldƒ±rƒ±ya ba≈ülama e≈üiƒüi d√º≈ü√ºr√ºld√º (10 -> 8)
            if (soldiers.length > 8) {
                const playerTC = entities.find(e => e.team === TEAM_PLAYER && e.type === 'towncenter');
                if (playerTC) soldiers.forEach(s => {
                    if (s.state === 'idle' || s.state === 'move') { // Sadece bo≈ütaki veya hareket eden birimleri saldƒ±rƒ±ya g√∂nder
                        s.state = 'attack'; s.target = playerTC;
                    }
                });
            }
        }

        function enemyBuildAI() {
            if (isGameOver) return;
            const enemyTC = entities.find(e => e.team === TEAM_ENEMY && e.type === 'towncenter'); if (!enemyTC) return;

            const buildingTypes = ['house', 'house', 'barracks', 'tower'];
            const type = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];

            const angle = Math.random() * Math.PI * 2;
            const dist = 100 + Math.random() * 250;
            const bx = enemyTC.x + Math.cos(angle) * dist;
            const by = enemyTC.y + Math.sin(angle) * dist;

            const tooClose = entities.some(e => ['house', 'barracks', 'tower', 'towncenter'].includes(e.type) && Math.hypot(e.x - bx, e.y - by) < 60);

            if (!tooClose) {
                let b = new Entity(bx, by, type, TEAM_ENEMY);
                b.constructionProgress = 100;
                entities.push(b);
                createParticles(bx, by, '#bdc3c7', 5);
            }
        }

        window.onresize = () => { SCREEN_W = window.innerWidth; SCREEN_H = window.innerHeight; CANVAS.width = SCREEN_W; CANVAS.height = SCREEN_H; };
    </script>
</body>

</html>
